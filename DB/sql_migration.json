[
  {
    "step": "Add SQLite Library (Static)",
    "details": "Integrate the SQLite3 library into the build and link it statically for both Linux and Windows. For example, include the SQLite amalgamation source (`sqlite3.c` and `sqlite3.h`) in the `third-party/sqlite` directory into the project. Update **CMakeLists.txt** to compile `third-party/sqlite/sqlite3.c` and link it into the `nls` executable.:contentReference[oaicite:0]{index=0}:contentReference[oaicite:1]{index=1} Enable optimization flags for SQLite (e.g. define `NDEBUG` for release, use `-O3`). Ensure thread safety is enabled if needed (SQLite default is threadsafe) or disable it for slight performance gain if the DB is only accessed on one thread. No external SQLite library should be required – the goal is to statically link the compiled SQLite code into the binary for portability."
  },
  {
    "step": "Embed or Bundle Default Database",
    "details": "Include the prepared SQLite database (`DB/NLS.sqlite3`) as a resource so that the application can access default themes/icons at runtime. Bundle the DB file with the install (similar to how YAML files were handled). Install `NLS.sqlite3` to the 'DB' config directory that previously held YAML (e.g. `/etc/dm17ryk/nicels/DB/NLS.sqlite3` on Linux, and `<install_dir>\\DB\\NLS.sqlite3` on Windows). Mark this file as a config file in packaging (so user edits persist upgrades, analogous to YAML). Update CPack/NSIS packaging: remove installing `*.yaml` files and instead install this DB file to the proper location:contentReference[oaicite:2]{index=2}:contentReference[oaicite:3]{index=3}. Ensure the application knows where to find the DB. The simplest path is to use the existing config search logic (see next step) to locate `NLS.sqlite3` in the install dirs. This keeps user override support: advanced users can replace or modify the installed DB, or provide a separate copy in their home directory to override defaults."
  },
  {
    "step": "Adjust ResourceManager for SQLite",
    "details": "Modify the resource search logic to handle the SQLite database instead of multiple YAML files. In **ResourceManager::initPaths**, stop assuming a `yaml` subdirectory for config files (or continue using it to maintain compatibility but it will now contain the DB). For example, on Linux add the directory `/etc/dm17ryk/nicels` (or `/etc/dm17ryk/nicels/DB`) to the search paths (replace the old YAML path):contentReference[oaicite:4]{index=4}. On Windows, use `%APPDATA%\\nicels` (and/or `%APPDATA%\\nicels\\DB`) as the user config dir as before:contentReference[oaicite:5]{index=5}. The environment override (`NLS_DATA_DIR`) should point to a directory containing the DB file; if set, look for `NLS.sqlite3` in that directory first:contentReference[oaicite:6]{index=6}:contentReference[oaicite:7]{index=7}. Implement a new `ResourceManager::find()` behavior for the DB: instead of taking arbitrary filenames, it will primarily look for the single database file. For clarity, you can create a small helper (e.g., `ResourceManager::findDatabase()`) that tries to locate `NLS.sqlite3` in the configured search dirs (env dir first, then current dir, exe dir, system dir, user dir last). Use the first occurrence found as the database path. If no external DB is found but an embedded DB is compiled in (Option 2 above), use the embedded data. Ensure that `ResourceManager::userConfigDir()` still returns the user directory (e.g. `~/.nicels/DB`) so we know where a user-provided DB would live. We will use this in the next step to implement override behavior."
  },
  {
    "step": "Load Configuration from SQLite DB at Runtime",
    "details": "Replace all YAML parsing in **Theme** and related classes with SQLite queries to load themes, colors, and icons. Initialize a SQLite connection (e.g. using `sqlite3_open_v2`) to the config DB path found by ResourceManager. Open in read-only mode (since the app only reads config). **Theme colors**: In `Theme::ensure_loaded()`, remove calls to `load_theme_file(\"dark_theme.yaml\")` and `load_theme_file(\"light_theme.yaml\")`:contentReference[oaicite:8]{index=8}. Instead, query the database for theme data. For example, to load the Dark theme colors: `SELECT element, c.value FROM Theme_colors t JOIN Colors c ON t.color_id = c.id WHERE t.id = 1;` (assuming theme ID 1 = 'Dark':contentReference[oaicite:10]{index=10}). Iterate over the results: for each `element` name, retrieve the color value (the integer stored) and convert it to the ANSI color code string. The conversion can use a helper similar to the existing `MakeAnsi(r,g,b)` in ThemeSupport, splitting the 24-bit integer into R, G, B components. Populate `Theme::dark_` (a ThemeColors map) with these values. Do the same for Light theme (theme ID 2). Also handle custom themes: if the user specifies a `--theme <name>`, search the DB for a theme with that name (e.g. `SELECT id FROM Themes WHERE name = ?`). If found, load its colors via the same process (or if not found, show an error as currently done:contentReference[oaicite:11]{index=11}:contentReference[oaicite:12]{index=12}). **Icons**: In `Theme::load_icons()`, remove all usage of `YamlLoader::LoadSimpleMap` and merging:contentReference[oaicite:13]{index=13}:contentReference[oaicite:14]{index=14}. Instead, query the SQLite DB tables. For file icons, do `SELECT name, icon FROM Files;` and fill `icons_.files` map. For each row, use the `name` (file extension) as key (already lower-case in the DB) and the `icon` text as value. Do similar for folders: `SELECT name, icon FROM Folders;` into `icons_.folders`. Then load aliases: `SELECT alias, name FROM File_Aliases;` and populate `icons_.file_aliases` (the current code uses lower-case keys, but the DB data should already be normalized to lower-case:contentReference[oaicite:15]{index=15}:contentReference[oaicite:16]{index=16}). Likewise `SELECT alias, name FROM Folder_Aliases;` for folder_aliases. After this, the in-memory maps contain icons for all known extensions and folders. We no longer need to merge multiple sources because the DB has combined data (YAML + Excel). However, preserve the existing fallback logic for safety: e.g., if a generic \"file\" or \"folder\" icon entry is missing, insert the default icon (as the code does at the end of load_icons():contentReference[oaicite:17]{index=17}). Close the SQLite connection when done (or keep it open if needed throughout program, but since all data is read into memory at startup, closing after loading is fine)."
  },
  {
    "step": "Preserve User Overrides",
    "details": "Ensure that a user-supplied SQLite file in the user config directory can override the defaults. The strategy will differ from YAML merging: we will choose one DB file to load. Implement the logic such that if a user has `~/.nicels/yaml/NLS.sqlite3` (or whichever path is returned by `ResourceManager::userConfigDir()` plus the filename), the program will prefer that over the system DB. Specifically, after initializing ResourceManager paths, check for the user DB file: if it exists **and** we did not use an env override, use the user DB path as the target for sqlite3_open. If the user DB does not exist, fall back to the system DB (in `/etc` or installed location) located via ResourceManager::findDatabase. (If an env override directory is set, that always takes highest priority and we use the DB from there, consistent with current behavior:contentReference[oaicite:18]{index=18}.) Document this behavior if needed: it mirrors the YAML override system, except that we do not merge at the entry level but instead wholly use one DB. This means users who want to customize a few entries may need to copy the default DB and edit it. We consider this acceptable given the advanced nature of such customization. Make sure that if the chosen DB file is missing or cannot be opened, the code prints an error or warning (and perhaps falls back to internal defaults as a last resort, using the compiled-in fallback theme/colors:contentReference[oaicite:19]{index=19}:contentReference[oaicite:20]{index=20})."
  },
  {
    "step": "Remove YAML Support and Update Documentation",
    "details": "With the code now loading all config from SQLite, purge the YAML system to clean up the project. Remove the `yaml_loader.h/cpp` source and any yaml files in the repository that are no longer needed. Update the CMake configuration: eliminate references to installing YAML files:contentReference[oaicite:21]{index=21} and update any install paths (for example, set `NLS_GLOBAL_CONFIG_INSTALL_DIR` to `/etc/dm17ryk/nicels` or similar instead of the `yaml` subfolder, or remove that variable if no longer needed). In the packaging scripts (CPack/NSIS), remove sections dealing with copying YAML, and include the DB file as needed:contentReference[oaicite:22]{index=22}:contentReference[oaicite:23]{index=23}. Similarly, adjust `tools/install_nls_user.sh` to copy the SQLite DB to `~/.nicels` (or `~/.nicels/yaml`) for user installs instead of YAML files. Update documentation: the README and man page should no longer refer to editing YAML files or the YAML config directory. For example, mention that the config is stored in `NLS.sqlite3` and can be overridden by placing a modified copy in the user config directory. Remove or rewrite sections like the Windows installer note and Linux package note that currently talk about YAML locations:contentReference[oaicite:24]{index=24}:contentReference[oaicite:25]{index=25}. After removal, thoroughly test the application: build on both platforms and run `nls` to ensure it produces the same output as before. Test `--light` and `--dark` flags to confirm themes switch correctly using DB data. Test a variety of file extensions and folder names to verify icons appear as expected (compare against the previous YAML-driven version outputs). Also test the `--theme <name>` option with a custom theme (if a user added one to the DB) or ensure it errors out appropriately if not found. Finally, verify that running `nls db --set-file` as a regular user bootstraps a personal `NLS.sqlite3` and that the data merges correctly with the packaged defaults. All tests should pass, and performance should remain on par (loading from SQLite should be very fast – if needed, measure that `theme::ensure_loaded` and `load_icons` timings are comparable or better than with YAML). Once confirmed, the migration from YAML to SQLite is complete."
  }
]
