[
  {
    "step": "Add SQLite Dependency",
    "details": "Integrate SQLite into the NiceLS build. For example, add the SQLite3 library: either include the amalgamation source (sqlite3.c/h) in the project or find and link against SQLite via CMake. Ensure that the library is compiled with optimization and thread-safety. Update CMakeLists.txt to compile sqlite3.c or find_package(SQLite3) as needed."
  },
  {
    "step": "Design & Create Database Schema",
    "details": "Define the SQLite schema for all data currently in YAML. Create tables: Colors, Themes, ThemeColors, Files, FileAliases, Folders, FolderAliases with appropriate columns and PRIMARY/FOREIGN keys as discussed. Use DDL statements to create these tables in a new database file (e.g., 'nicels.db'). Ensure to allow multiple aliases per file (no unique constraint on FileAliases.target) and multiple theme entries (composite primary key on ThemeColors). This can be done via an SQL script or via the SQLite C API at runtime. Verify the schema matches the data needs."
  },
  {
    "step": "Populate SQLite DB with YAML and Excel Data",
    "details": "Write a migration script or code to transfer data from existing YAML files and the provided Excel into the SQLite database. This could be a one-time utility. Steps: (1) Parse colors.yaml, insert color name/value into Colors. (2) Insert default themes ('Dark','Light') into Themes. (3) Parse dark_theme.yaml and light_theme.yaml; for each entry, find the color (if hex or name) and insert into ThemeColors(theme_id, element, color_id). (4) Parse files.yaml, insert each extension and icon into Files (with placeholder description/used_by). (5) Parse folders.yaml, insert into Folders. (6) Parse file_aliases.yaml and folder_aliases.yaml, insert into FileAliases and FolderAliases respectively (ensuring target exists in Files/Folders; if not, create it or handle accordingly). (7) Open the Excel (known-file-extensions.xlsx), iterate over each row: for each extension, update or insert the corresponding Files entry with description, used_by, icon, class name, codes. Use Excel data to override defaults if conflict. It's fine to do this in Python or another environment if easier, then import the SQL—what matters is the final DB contains all combined data. Ensure to commit all changes. Verify key samples in the DB."
  },
  {
    "step": "Embed or Distribute the SQLite DB",
    "details": "Decide how the application will access the DB. E.g., ship 'nicels.db' as a resource file (installed to the same directory as the binary or a well-known path like /etc/dm17ryk/nicels/). Modify installation scripts (CPack/NSIS, packaging) to include the SQLite database instead of YAML files in the appropriate location (e.g., /etc/dm17ryk/nicels/nicels.db for Linux, and in the install dir for Windows). Remove references to installing YAML in CMake packaging scripts, and add the DB file. Also, if needed, provide a mechanism for user overrides (could consider having a separate user DB or instruct advanced users to edit the DB). Initially, focus on making sure the default DB is accessible."
  },
  {
    "step": "Update Configuration Loading Code",
    "details": "Modify NiceLS code to use the SQLite DB instead of YAML. Key places: **ResourceManager** and **Theme** classes. For example, in ResourceManager, where it searched for YAML files in various directories:contentReference[oaicite:41]{index=41}:contentReference[oaicite:42]{index=42}, now search for 'nicels.db' file in those locations (NLS_DATA_DIR env override, current dir, exe dir, system dir, user dir). Load that path or fall back to compiled-in defaults if not found. In Theme::ensure_loaded (src/theme.cpp), remove calls that load YAML files (`load_theme_file(\"dark_theme.yaml\")`, etc.:contentReference[oaicite:43]{index=43} and `load_icons()` which reads files.yaml:contentReference[oaicite:44]{index=44}). Instead, open the SQLite database (e.g., via a singleton DB connection object). Query the database for needed data: \n- When initializing theme colors: load all entries from ThemeColors for the selected theme into the ThemeColors structure. For example, `SELECT c.value FROM ThemeColors t JOIN Colors c ON t.color_id = c.id WHERE t.theme_id = ?;` for each element or load all and fill a map. Populate `Theme::dark_` and `Theme::light_` from the DB rather than YAML.\n- When loading icons: similarly, replace `YamlLoader::LoadSimpleMap` on files.yaml with a SQL query. E.g., execute `SELECT name, icon FROM Files;` and fill `icons_.files` map. Do `SELECT alias, target FROM FileAliases;` to fill `icons_.file_aliases` map (the code uses lowercase keys, so lower-case the alias and target as needed). Do the same for folders and folder_aliases:contentReference[oaicite:45]{index=45}. Essentially, one query per table to populate the in-memory maps.\nRemove or bypass the YamlLoader module entirely if it's no longer needed (the YAML files will not be packaged). The `ResourceManager::find()` logic can be simplified to just locate the DB file. Make sure to handle the case where the DB is missing or unreadable – in such case, perhaps emit an error or fall back to the compiled-in defaults (similar to how missing YAML was handled gracefully:contentReference[oaicite:46]{index=46})."
  },
  {
    "step": "Remove YAML Dependencies and Test",
    "details": "Clean up any remaining YAML references. This includes: removing YAML files from the repository (or marking them as deprecated), updating documentation (README should no longer refer to editing YAML, but perhaps instruct how to update the DB or that the DB is the new source of truth for themes/icons). Remove the `yaml_loader.cpp/h` and any yaml parsing logic if it's now unused. \nRebuild the project and run tests/manual tests: verify that running `nls` produces the same outputs as before. Specifically, check that colors and icons appear correctly. Test with `--light` and `--dark` options to ensure theme loading from DB works (colors change accordingly). Test a variety of file extensions to ensure icons show up (especially ones that were previously configured via YAML and new ones from the Excel list). \nPerformance test: list a directory with many files to ensure there's no noticeable slowdown. The expectation is that with either in-memory caching or fast DB lookups, performance remains excellent. If any regressions appear, profile and consider caching more data in memory. \nOnce confirmed, remove any YAML install routines (e.g., the code in install_nls_user.sh that copied YAML – update it to handle the DB if needed). The application should now rely solely on the SQLite database for configuration."
  }
]
