{
  "title": "Refactor Resource Paths Module (Encapsulate Resource Directory Management)",
  "description": "Encapsulate the logic for managing YAML resource file paths into a dedicated class or namespace instead of using free functions with static locals. Currently, `resources.cpp` holds free functions `init_resource_paths` and `find_resource` which manipulate a static `std::vector<std::filesystem::path>` of directories and a static initialized flag:contentReference[oaicite:118]{index=118}. This task will create a ResourceManager (or similar) to manage these paths, eliminating hidden global state and making the interface more object-oriented.",
  "goals": [
    "Introduce a `ResourceManager` class (or namespace with internal static state) that will handle initialization of resource lookup paths and searching for resource files. It should provide methods analogous to `init_resource_paths(argv0)` and `find_resource(name)` but as class methods (e.g., `ResourceManager::initPaths(const char*)` and `ResourceManager::find(const std::string&)`).",
    "Maintain the current search logic: include environment variable override (`NLS_DATA_DIR`), current working directory `yaml` subfolder, and paths relative to the executable’s location (both the exe’s directory and its parent’s `yaml` directory) in the search list, preserving the order. The new ResourceManager should be initialized with these in exactly the same way as now.:contentReference[oaicite:18]{index=18}:contentReference[oaicite:19]{index=19}",
    "Ensure that the list of resource directories is stored internally in ResourceManager (for example, as a private member std::vector<fs::path>). Remove the static free function `resource_dirs()` and the `resources_initialized` flag; ResourceManager can handle initialization idempotently (e.g., by checking if its vector is empty or by maintaining an internal bool).",
    "Update all code that uses `init_resource_paths` and `find_resource` to use the new interface. For instance, App::run currently calls `init_resource_paths(argv0)` early in execution:contentReference[oaicite:20]{index=20} – this should be replaced with a call to ResourceManager (either a static call or via an instance). Similarly, Theme loading uses `find_resource(...)`:contentReference[oaicite:21]{index=21}; it should call the ResourceManager’s find method.",
    "Eliminate any remaining global or static variables related to resource paths. After this refactor, the only global state for resources should be possibly a singleton ResourceManager if implemented that way (which is acceptable), or an App-owned ResourceManager passed around. In either case, the management is encapsulated rather than via free functions."
  ],
  "scope": [
    "Design the ResourceManager class in `resources.h`. This class can be a singleton (with `ResourceManager::instance()` returning a reference) since resource paths are inherently a global concept in the application (they don’t change per object). Alternatively, it can have static methods and an internal static vector. The key is to hide the global vector behind an interface. For example, a simple design is:\n```cpp\nclass ResourceManager {\n  public:\n    static void initPaths(const char* argv0);\n    static std::filesystem::path find(const std::string& name);\n  private:\n    static std::vector<std::filesystem::path> dirs;\n};\n```\nThis would replace the current free functions and static `dirs`. Implement this (with thread-safe init if needed, though single-thread init is fine).",
    "Implement `ResourceManager::initPaths` in `resources.cpp` to perform the same steps as the current `init_resource_paths`: check an `initialized` guard (which could be a static bool or simply check if `dirs` is non-empty) to avoid re-running, then populate `dirs` with environment path if set:contentReference[oaicite:22]{index=22}, current directory’s `yaml` subdir:contentReference[oaicite:23]{index=23}, and the executable’s `yaml` paths:contentReference[oaicite:24]{index=24}. Use `argv0` to find the executable’s location just as in current code (canonicalizing the path, etc.).",
    "Implement `ResourceManager::find` to iterate over the stored `dirs` and look for the given file name in each, returning the first match as a path (or empty path if not found), same as current `find_resource` does:contentReference[oaicite:25]{index=25}.",
    "Replace calls: In App::run, replace the free function call with `ResourceManager::initPaths(argv0)` (assuming static methods). In Theme or other modules that call `find_resource(name)`, replace with `ResourceManager::find(name)`. Make sure to `#include \"resources.h\"` where needed after this change (likely already included).",
    "If `ResourceManager` is a singleton instance rather than purely static methods, you would do something like `ResourceManager::instance().initPaths(argv0)`; ensure that instance is accessible globally (perhaps managed as Meyers singleton inside instance()). The static method approach is simpler here and acceptable, since it’s effectively the same as the free functions but namespaced in a class for clarity and grouping.",
    "Document the ResourceManager usage in code comments: e.g., note that it should be initialized early (App does it) and then can be used anywhere to find resources. Ensure that calling find without init does not crash (in practice, App should always call initPaths first). Perhaps as a safety, if find is called and dirs is empty, it could call initPaths implicitly with argv0=nullptr (though not strictly necessary)."
  ],
  "exclusions": [
    "No changes to how theme YAML files are structured or loaded beyond the path search. We are not modifying YAML file contents or introducing new config files; only how we locate them on disk.",
    "Do not hard-code any new paths. Continue to rely on the logic and environment variables in place. For example, if NLS_DATA_DIR is not set, we search relative to the executable and current directory as before – no additional directories.",
    "Avoid introducing global state beyond the ResourceManager itself. For instance, do not expose the internal vector of paths publicly or allow external modification of it except via the provided methods. The goal is controlled access.",
    "This refactor is not about error handling improvements or user feedback; if a file isn’t found, the behavior remains returning an empty path (and later code prints an error about missing resource if appropriate). Do not add new error prints or exceptions – keep the behavior consistent with current (silently return empty if not found).",
    "Do not intertwine this with Theme’s internal logic more than necessary. Theme will call ResourceManager to get file paths, but Theme does not need to become a friend or deeply integrated class. Keep ResourceManager as a utility that Theme (and potentially other modules like icons loader) use."
  ],
  "architectural_recommendations": [
    "Using a class to wrap resource path logic improves clarity: readers know all resource directory logic is in one place. The static methods approach keeps usage simple (no need to pass an object around). This is effectively a Singleton but in a controlled, minimal form, which aligns with our allowance of singletons for global lifetime necessities (resource paths are a global concern, similar to Config).",
    "Make sure to handle platform differences in path construction as in current code. The existing implementation already covers Windows vs POSIX differences by using std::filesystem and environment variables. For example, on Windows `argv0` might be an absolute path with backslashes – std::filesystem handles that. Just ensure we continue to call `weakly_canonical` or `lexically_normal` to normalize paths:contentReference[oaicite:26]{index=26}:contentReference[oaicite:27]{index=27}.",
    "Thread safety: Since initPaths is called early in a single-thread context (from App initialization), we don’t have to heavily guard the static vector. A simple static bool check is sufficient to avoid double-initialization. If we wanted to be extra safe, we could use a call_once or lock, but likely overkill here. Document that initPaths should not be called concurrently.",
    "Testing: After refactoring, test that the application still finds theme files and icon files as before. For instance, run the program in a scenario where `NLS_DATA_DIR` is set to a custom path and ensure that those files are loaded from that location. Also test without NLS_DATA_DIR to ensure the fallback to bundled `yaml/` works. Since we didn’t change logic, this is just a sanity check.",
    "Consider future extensibility: With ResourceManager in place, adding new resource types or directories (if needed later) becomes easier. The design should allow (in the future) adding another directory to search by just modifying ResourceManager’s initialization, without touching other modules. Keep the interface general (e.g., `find(resourceName)` could be used for any resource file like icons, colors, etc., not just limited to current YAML files)."
  ],
  "cli_considerations": [
    "This refactor does not change any user-facing options or invocation. It happens behind the scenes. The only indirect CLI-related consideration is that the program should still be invoked with the same steps (no new arguments needed) and it will find its data files. For example, after building, running `nls` without installation should still locate the `yaml` directory as it does now. That means our `initPaths` still uses the location of the `nls` binary (argv0) to look for a sibling `yaml/` folder – which it will, just as before.",
    "If a user sets the `NLS_DATA_DIR` environment variable to point to custom theme files, the new ResourceManager must honor that (as the current code does by checking the env var first). Make sure to test that scenario with the CLI, e.g., `NLS_DATA_DIR=/some/path nls --light` uses the YAML in /some/path rather than the bundled ones.",
    "The timing of calling `ResourceManager::initPaths` is important. Currently it’s called at the start of App::run:contentReference[oaicite:28]{index=28}, before theme initialization. We should keep it that way: the CLI help or usage doesn’t depend on it, but theme and icon loading does. So ensure App still calls this before any Theme::initialize or YAML loads occur. If, for instance, someone called `nls --help`, CLI11 might exit before initPaths – that’s fine, as no resources are needed in that case. Our design can tolerate `initPaths` not being called if the program exits before needing resources (or we call it regardless, which is harmless)."
  ]
}
