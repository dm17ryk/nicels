{
  "title": "Refactor Git Status Formatting (Integrate Git Prefix Logic into Module)",
  "description": "Encapsulate the logic for formatting Git status prefixes into the appropriate modules instead of as free functions in App. Currently, determining the two-character Git status codes and constructing the colored prefix string (including the checkmark for clean directories) is done in static helper functions `StatusModesFor` and `FormatGitPrefix` within App.cpp:contentReference[oaicite:121]{index=121}. This task will move that functionality into either the GitStatus class (for status code mapping) and/or the Renderer (for output coloring), eliminating these free functions and aligning with an object-oriented structure.",
  "goals": [
    "Move the `StatusModesFor` logic into the GitStatus module or the GitStatusResult structure. For example, implement a method in `GitStatusResult` (or `GitStatus`) that given a relative path (filename) returns the set of status code strings for that entry (or null if none). This replaces the free function and keeps the knowledge of how status entries are stored encapsulated within GitStatus:contentReference[oaicite:121]{index=121}.",
    "Move or rewrite the `FormatGitPrefix` functionality inside a class method. There are two possible approaches: **(a)** Add a function in the Renderer (since it handles output formatting and coloring) to produce the git prefix string for a given Entry using the data from GitStatusResult; or **(b)** add a function in GitStatus (or a small utility class) that returns the formatted prefix given a GitStatusResult and flags (no_color, etc.). Approach (a) keeps output responsibilities in Renderer, whereas (b) centralizes git-specific formatting in GitStatus – either is acceptable as long as free functions are eliminated and design is clean.",
    "Preserve the exact output format and coloring for Git status as currently implemented. That means the logic that decides when to show the checkmark (✓) for a clean directory, when to pad with spaces, and how to color each status character must remain the same:contentReference[oaicite:2]{index=2}:contentReference[oaicite:3]{index=3}. After refactoring, the output of a directory listing with `--git-status` should be identical to current behavior.",
    "Ensure that Theme is still used for color codes (addition, modification, deletion, untracked, etc.) rather than hard-coding colors. The refactored solution should fetch color codes via Theme’s interface (`theme.color_or(...)`) just like the current code does:contentReference[oaicite:4]{index=4}. This might mean Renderer (which already has access to Theme via Theme::instance()) is a good place to do the coloring step.",
    "Make the code more maintainable: by integrating this logic into classes, future changes to Git status output (or adding new status codes) can be done in one place. Also, by eliminating these static functions, App logic becomes simpler (it would just call e.g. `gitStatus.formatPrefix(entry)` or Renderer does it internally)."
  ],
  "scope": [
    "Augment the `GitStatusResult` struct (defined in git_status.h) with a method, e.g., `const std::set<std::string>* modesFor(const std::string& rel_path) const`. This method will implement what `StatusModesFor` does: take a relative path, strip any subdirectory portion (the part after a '/'), and then look up in the `entries` map for that key, or return `default_modes` if the key is empty. This keeps the mapping logic inside GitStatusResult.:contentReference[oaicite:5]{index=5}",
    "In the GitStatus class (or GitStatusResult), add a function to generate the raw prefix symbol string (without coloring) for a given file entry. For example, `std::string GitStatus::getPrefixSymbols(const GitStatusResult&, const Entry& entry)` that returns either \"  ✔ \" (checkmark with padding) or the set of status letters (with appropriate padding to 3 chars plus a space) as currently constructed in FormatGitPrefix:contentReference[oaicite:6]{index=6}:contentReference[oaicite:7]{index=7}. This function would incorporate the logic of whether a repo was found, whether any codes are present (`saw_code`), and assembling the symbol string but without color codes (just the characters and spaces).",
    "Decide where to apply colors: One way is to have Renderer take the symbol string from GitStatus and then apply Theme colors. Alternatively, have GitStatus (which knows Theme as well, since it can call Theme::instance()) return an already colored string. The current FormatGitPrefix applies colors inline:contentReference[oaicite:8]{index=8}:contentReference[oaicite:9]{index=9}. To maintain separation, consider having GitStatusResult carry the raw codes and let Renderer handle coloring: e.g., Renderer could iterate over each character of the symbol string and wrap it in the appropriate color escapes using Theme (similar to the switch in FormatGitPrefix). This way Renderer does all output formatting. If this is too complex to reimplement, it’s acceptable to have a static helper in Renderer or a method in GitStatus that does “colorization” by essentially moving the code from FormatGitPrefix into that method.",
    "Implement a new method in Renderer, say `Renderer::printGitPrefix(const Entry& entry, size_t width)`, or incorporate it into existing printing functions, to output the git prefix for an entry. Renderer knows if git status is enabled (Config.git_status) and can fetch `entry.info.git_prefix` (which might now be just the raw code or could be eliminated in favor of computing on the fly). One approach: do not store `git_prefix` string in FileInfo at all, instead compute it during rendering. For instance, Renderer when printing a line can call `modes = gitStatusResult.modesFor(name)`, then get symbol string, then apply colors. However, computing once in App and storing in Entry might be simpler and was done to separate concerns. Either approach is valid: if storing, we will still populate `entry.info.git_prefix`, but do it via a GitStatus/GitStatusResult method rather than FormatGitPrefix free function.",
    "Refactor App::applyGitStatus accordingly. If Renderer now handles prefix formatting, App::applyGitStatus could be simplified to just retrieving the GitStatusResult for the directory (perhaps still via `gitStatus.getStatus(dir)`) and storing it or passing it to Renderer. If we keep populating entries with prefix, then replace the call to `FormatGitPrefix(...)` with a call to the new method (either a GitStatus method or a Renderer static) and assign the result to `entry.info.git_prefix`.:contentReference[oaicite:10]{index=10}",
    "Update unit tests or add new ones for the GitStatus formatting logic if available. Ensure that combinations of statuses (e.g., files with multiple codes like \"RM\" for renamed and modified) still appear correctly in the output with the right unique letters in sorted order as before (the current logic collects unique chars into a set `glyphs`:contentReference[oaicite:121]{index=121}). This behavior should remain unchanged."
  ],
  "exclusions": [
    "Do not change when or how `git_status` is invoked beyond moving the code into methods. The frequency and timing of GitStatus checks (one per directory listing) remains the same. We are not introducing caching beyond what may already exist, nor changing the libgit2 usage.",
    "Do not alter the fundamental format of the git status prefix. It must remain a 4-character field (either two letters + space, or \"  ✔ \" with a check, or four spaces) as per current design. No adding or removing characters. Also ensure color codes remain the same ANSI sequences as defined in the theme YAML (fallback to green for clean, etc.).",
    "This is not introducing dynamic configuration of git symbols or colors; use the Theme as currently to fetch colors, and the symbols themselves (like the checkmark ✓ U+2713 for clean) remain hardcoded as in current logic.:contentReference[oaicite:11]{index=11} We are just moving the code into a different place, not altering its content.",
    "Avoid any direct printing inside the GitStatus module – it should return data, not print. Printing still should be handled by Renderer (or App in some cases). So, GitStatus should provide either data or a ready string, and Renderer/App prints it. No console output from within GitStatus methods.",
    "No changes to Theme module aside from possibly needing to include it where the new code lives (since coloring uses Theme). The refactor should not require modifying how Theme itself works."
  ],
  "architectural_recommendations": [
    "Between the two main approaches (handling coloring in Renderer vs in GitStatus), lean toward keeping presentation logic in Renderer. Renderer already has `Theme` and knows about output width alignment, etc. GitStatus’s job can be just to provide raw status data. Perhaps have GitStatusResult hold the sets of codes, and Renderer can be responsible for mapping those to colored output. For example, Renderer could have an internal table or logic (like the switch-case currently in FormatGitPrefix) for each possible char ('?' -> use theme \"untracked\", 'M' -> \"modification\", etc.). This separates concerns: GitStatus doesn’t need to know about ANSI codes, it only knows status codes.",
    "However, to minimize duplication, you might choose to reuse the existing logic by moving it as-is. One compromise: implement `GitStatus::formatPrefix(const GitStatusResult&, const std::filesystem::path& dir, bool is_dir)` that returns the colored string exactly as FormatGitPrefix did. Renderer can simply output that string. This keeps all git prefix logic in one place (GitStatus), at the cost of mixing data and presentation a bit. Given the code size is small and already intertwined with Theme calls, this is acceptable if it simplifies the refactor.",
    "Whichever place you choose to implement the formatting, make sure to handle the `no_color` case (user disabled color) gracefully. If Renderer is doing it, it knows `opt_.no_color()` from Config; if GitStatus does it, it should accept a flag for no_color (like FormatGitPrefix does). The colored output should be omitted or replaced with plain symbols when no_color is true:contentReference[oaicite:12]{index=12}:contentReference[oaicite:13]{index=13}.",
    "Maintain efficiency: The current implementation avoids constructing color codes for each file repeatedly by caching them in local strings (`col_add`, `col_mod`, etc. at each call). In the refactor, be mindful of performance in large directories. If Renderer calls Theme for each file entry separately, it might be slightly less efficient. It could be fine, but you might also compute the color strings once per directory listing (e.g., store them from Theme in local variables) as done now. Perhaps the GitStatusResult could even hold the `repository_found` flag and default_modes, making it easy to decide if a clean checkmark is needed without re-checking for each file.",
    "The design should also consider testability: by having GitStatusResult provide mode sets and a separate formatting function, you could test the formatting logic independently by constructing a fake GitStatusResult with certain entries and ensuring the output string matches expected. This is easier when the logic is in a function (either static or instance method) rather than a deeply embedded free function."
  ],
  "cli_considerations": [
    "`--git-status`: This flag controls whether we call GitStatus at all. After refactoring, ensure that if this flag is false, none of the new formatting code runs. For instance, Renderer should only add git prefixes if Config.git_status is true. App should perhaps skip calling `GitStatus::getStatus` entirely if the flag is false (as it does now by guarding applyGitStatus). That guard must remain in place so performance isn’t impacted when the user doesn’t request git info.:contentReference[oaicite:14]{index=14}",
    "Output alignment: The git status prefix takes up space in the output. The current code calculates a `w_git` (width for git column) in Renderer to align columns:contentReference[oaicite:15]{index=15}. Ensure that this calculation still works with the refactored approach. If Renderer now computes the prefix on the fly, it should also compute `w_git` consistently (e.g., by measuring the length of prefix strings, taking into account that colored strings have invisible characters). There is already logic (`PrintableWidth`) to compute visible width of strings with ANSI codes:contentReference[oaicite:16]{index=16} – use that to include git prefix in width calculations if needed.",
    "Verify scenarios: If a directory is a Git repository with no changes, the output for that directory’s header line should show the checkmark (✓) if `--git-status` is on and the directory is empty (or all clean). If the directory is not a Git repo, the prefix area should be blank. If files have mixed statuses, the letters should show exactly as before. Testing with known cases (e.g., create a git repo with one modified file, one untracked file, etc.) will ensure your refactored code prints the same prefixes.",
    "Color disabling: If user runs `--color=never` along with `--git-status`, the git status letters should appear but uncolored (except the checkmark which will just be the character with no green color). Make sure the `no_color` flag from Config is properly passed or checked in the new code so that in this case `col_clean` etc. are not applied (currently handled by `no_color || col_clean.empty()` checks in FormatGitPrefix:contentReference[oaicite:17]{index=17}). The new implementation should include equivalent logic."
  ]
}
