{
  "title": "Modernize Utility Functions and Formatting (Adopt C++23 Features)",
  "description": "Update and refactor various utility functions and formatting code throughout the project to utilize modern C++23 facilities and more idiomatic practices. This includes replacing C-style string manipulation and streams with `<format>` where appropriate, using `constexpr` and `<algorithm>`/ranges to simplify logic, and eliminating duplicate utility code. These changes will make the code more concise, safer, and aligned with current C++ standards without altering functionality.",
  "goals": [
    "Replace uses of C-style formatting and manual string assembly with `std::format` (from `<format>`) or other modern techniques. For example, in Theme module, the function constructing an ANSI color code uses `std::snprintf` into a buffer:contentReference[oaicite:29]{index=29}; refactor this to use `std::format` (e.g., `std::format(\"\\x1b[38;2;{};{};{}m\", r, g, b)`) to construct the string in a type-safe manner.",
    "Introduce `constexpr` for utility functions and constants that can benefit. For instance, the color name map in Theme’s `make_default_color_map` could be made `constexpr` (as a `static const std::unordered_map` or perhaps better, switch to `std::array` of pairs if constexpr construction is tricky) so it’s built at compile time:contentReference[oaicite:30]{index=30}:contentReference[oaicite:31]{index=31}. Similarly, any small character classification functions (like `hex_value` that converts a hex digit to int:contentReference[oaicite:32]{index=32}) can be made `constexpr static` functions, and lookup tables (if any) can be `constexpr`.",
    "Eliminate duplicate implementations of common functionality by consolidating them. For example, there are multiple implementations of trimming whitespace (`trim_copy` appears in both Theme.cpp and Yaml_loader.cpp):contentReference[oaicite:119]{index=119}:contentReference[oaicite:120]{index=120}. Unify these by having a single `StringUtils::Trim` (static function) or similar, and use it in both places. Likewise, ensure only one version of comment-stripping or case conversion exists (StringUtils already has ToLower, so use that instead of custom loops wherever applicable).",
    "Use modern library facilities for character and string handling: e.g., use `<cctype>` algorithms with `std::ranges` or `std::all_of/any_of` for checks instead of manual loops where it simplifies code. For instance, `IsNonGraphic` in Renderer returns `!std::isprint(ch)` – that’s fine; ensure it’s `constexpr` if possible, or even consider using `std::isprint` directly at call sites if the helper is trivial. Another example: replacing manual percent-encoding assembly in `PercentEncode` with an algorithm-based approach (though C++23 doesn’t have a built-in percent-encode, a range transform could express it more clearly).",
    "Improve usage of string views and spans to avoid unnecessary copies. Where functions currently take `std::string` but only read from it, consider using `std::string_view` for flexibility and efficiency (e.g., `IsHidden(const std::string&)` could be `IsHidden(std::string_view)`). In formatting, if assembling strings piecewise, consider `std::format_to` into an output iterator to avoid intermediate std::string allocations when building large output (this is an optimization; not mandatory if it complicates things)."
  ],
  "scope": [
    "Identify key areas to modernize:\n  - **Theme module:** refactor `make_ansi` to use `<format>`:contentReference[oaicite:33]{index=33}, possibly make `parse_hex_triplet` and `parse_color_triplet` use `std::stoi` or `<format>` for parsing if appropriate (though current logic is fine, just ensure it’s clear and maybe use `std::isdigit` instead of manual ranges). The default color map can be made `static const` (since it’s fixed) and possibly `constexpr` if the compiler allows initialization at compile time.\n  - **Renderer:** The use of `std::ostringstream` and `std::setw` for formatting in `ApplyControlCharHandling` and others can remain, but for any simpler concatenations, use `std::format`. For example, constructing file URIs (`file://` + encoded path) can be done with `std::format` instead of manual string ops:contentReference[oaicite:34]{index=34}:contentReference[oaicite:35]{index=35}. Ensure `EffectiveTerminalWidth` uses the new Platform function appropriately (currently it returns `Platform::terminalWidth()`:contentReference[oaicite:36]{index=36}, which is fine). If any calculation can be `constexpr` (like computing the number of columns for tree view prefix), consider it, but likely runtime is needed.\n  - **StringUtils:** Possibly add a `StringUtils::Trim` for trimming whitespace using algorithms (e.g., using `std::find_if` or ranges to find first/last non-space). Use this in both yaml_loader and theme instead of their local trim_copy. Also, ensure `StringUtils::EqualsIgnoreCase` and `ToLower` use `<algorithm>` (they probably do internally). If any code manually lowercases strings via loop, replace with `StringUtils::ToLower` or `std::ranges::transform` with `std::tolower`.\n  - **Yaml_loader:** replace the manual trim and comment removal with the new unified utilities. For example, after introducing `StringUtils::Trim`, use that inside yaml_loader’s loop instead of its own trim_copy:contentReference[oaicite:37]{index=37}. The comment stripping logic is a bit custom (skips # inside quotes); that can remain as it’s not standard, but could be made more concise (but focus on correctness; it’s fine to leave it if modernization doesn’t clearly simplify it).",
    "Ensure that uses of `<format>` do not change output formatting inadvertently. For example, using `std::format` to format numbers might yield different padding or format if not carefully specified. Always specify format specifiers that produce the same result as the old code. For instance, if using `std::format` to replace `std::setw` alignment, you might use format spec like `{:>N}` for right alignment of width N. In some cases, keeping `std::setw` might be simpler. So, use `<format>` primarily for constructing strings that were manually built or sprintf’d, rather than for aligning the tabular output (which is already handled well by iostream manipulators).",
    "Review any remaining uses of `new` or raw pointers in the code. At this point, most should be replaced by smart pointers or stack objects (for example, FileScanner and Renderer are created with `make_unique`, Config is a singleton on stack, etc.). If any raw `new`/`delete` or malloc/free exist (unlikely in this codebase), refactor to smart pointers or appropriate RAII wrappers. One specific check: the libgit2 usage might require manual allocation/free; ensure those are wrapped in safe abstractions (the GitStatus refactor likely introduced `unique_ptr` with custom deleters or at least ensures `git_status_list_free` is called). If not already done, that could be considered, but it might have been done in the GitStatus task.",
    "Update the build or compiler settings if needed to enable C++23 features (if not already enabled). Since our project targets C++23, using `<format>` and other features should be fine. Ensure `#include <format>` is present where needed and that we have `using namespace std::format_literals` if using format compile-time string literals (not necessary, but could be handy for `std::format` usage).",
    "After making these changes, run the test scenarios (or at least manually test the tool) to verify that behavior is unchanged. Pay attention to formatting edge cases: large file sizes still display correctly with the updated SizeFormatter (if we changed anything there), times are formatted the same, etc. Since this task is more about internal improvements, it should not affect outputs except in invisible ways (like perhaps slight differences in performance or compiled size)."
  ],
  "exclusions": [
    "Do not change the output alignment or spacing. The goal is not to reformat how the columns look, just to implement it in a more modern way if possible. For example, if replacing some `ostringstream` usage with `std::format`, make sure to include the same spacing/padding. The user should not be able to tell that the implementation changed in terms of the final printed format.",
    "Avoid using highly experimental or unstable features. Stick to standard C++23 library features that are well-supported (std::format, string_view, etc.). Do not introduce third-party dependencies or massively refactor logic just to use a new feature if it doesn’t clearly simplify things (for instance, do not replace logic with std::ranges if it becomes harder to understand than a simple loop). Clarity and maintainability are the priority, using modern tools as aids.",
    "We are not introducing multi-threading or parallel algorithms in this task. Even if `<ranges>` or algorithms could simplify some loops, ensure the behavior remains single-threaded and deterministic as before (no parallel execution for something like listing directory entries, as that’s outside scope and could affect output order).",
    "Do not change the logic of how sizes or times are formatted. The Formatter classes (SizeFormatter, TimeFormatter) should continue to output the same strings. If using std::format for times, ensure the format string is correct. If something isn’t easily done with std::format (like locale-specific formatting), it’s acceptable to keep using `std::put_time` or existing code. Only change what can be changed without loss of fidelity.",
    "No changes to user-facing messages or help text. This task is purely code-internal. For example, do not change the way error messages are constructed (unless using std::format to build the string, but the text stays the same)."
  ],
  "architectural_recommendations": [
    "Adopting `<format>` can reduce buffer overflow risks and make code more expressive. However, be mindful of performance in hot loops: e.g., if Format is used inside a loop for every file, check that it's not a bottleneck. `std::format` is generally fast, but constructing a new format string for thousands of files might be slightly slower than reusing an `ostringstream`. In critical sections (like printing each file line), it might be best to stick with pre-allocated `ostringstream` or at least reuse `std::format_to` on an existing buffer. Profile if needed, but given typical directory sizes, it should be fine.",
    "Using `constexpr` for lookup tables (like color name map) and utility functions can improve compile-time checking and possibly performance. Mark functions like `IsHidden` and `EqualsIgnoreCase` as `constexpr` if possible, so they can be evaluated at compile time for constant inputs. This doesn’t change runtime behavior but signals the compiler and developers that these functions have no side effects and could be computed at compile-time for const data.",
    "Unifying duplicate code in one place (e.g., trimming) will reduce maintenance. Implement the chosen approach (e.g., `StringUtils::Trim`) and thoroughly test it on various inputs (spaces, tabs, no whitespace) to ensure it behaves identically to the prior implementations. After replacing, remove the old static functions to avoid confusion (e.g., delete the now-unused `trim_copy` in yaml_loader and theme). This makes the codebase cleaner.",
    "Wherever using `std::ranges` or algorithms, ensure the intent is clear. Sometimes a simple for-loop is more readable. For instance, replacing a loop that checks each char with `std::any_of` can be neat. Use these tools judiciously to improve clarity or conciseness, not just to appear \"modern.\" Comments can help if a particular algorithm call is not immediately obvious.",
    "Take advantage of `std::string_view` especially in parsing routines (like splitting strings by colon in YAML loader:contentReference[oaicite:38]{index=38}). You can avoid creating temporary std::string for key and value by using substr views and trimming those. But be careful that the source (the line string) persists while the view is used (in yaml_loader, the line exists in a loop as a std::string; after trimming you could get a view into that string’s data – just ensure not to use the view after the string is modified or out of scope). Using string_view can reduce memory churn in tight loops."
  ],
  "cli_considerations": [
    "All these changes should be under the hood and not alter how the CLI is used or the output it produces for the user. The listings, help text, error messages, etc., should look the same. Therefore, when verifying, use sample CLI commands to compare output before and after. For example, `nls -l` on a directory should produce identical text (including spacing and coloring) after the modernization.",
    "One subtle CLI-visible aspect could be performance. If the user lists a very large directory, our changes (like using std::format) should not introduce a noticeable slowdown. The tool should remain responsive. If any change inadvertently causes a performance regression for large inputs, consider mitigating (perhaps by reserving buffers or reusing state). The goal is equal or better performance with clearer code.",
    "Another CLI consideration is error handling: e.g., if a resource file is missing, the current code might produce an error message like `nls: error: ...`. Ensure that any refactoring of resource lookup or others doesn’t change the wording or timing of such messages. We still want, for instance, `colors.yaml` missing to be reported in the same manner. (That said, in the current code, missing YAML might just result in default colors with no explicit error – just be sure not to introduce new output.)",
    "If any environment variables or locale settings affect the output (like `LS_COLORS` or `TIME_STYLE`), make sure your modernized code still respects those as before. For instance, if TimeFormatter was using `std::put_time` with locale, and you switch to `std::format`, ensure that you retrieve the equivalent locale or format string. However, time formatting was likely already handled; just double-check no behavior change in such edge cases.",
    "Test the colored output after changes, especially around the edges of newlines, resets, etc. For example, the code that appends `theme.reset` after coloring text:contentReference[oaicite:39]{index=39} should remain intact so that color doesn’t bleed into the next line. Using std::format to intermix literal escape sequences like `\"\\x1b[0m\"` is fine, just ensure the resulting string is correct. The CLI output should remain properly colorized with resets as before."
  ]
}
