{
  "title": "Refactor App Module (Orchestrate initialization and execution)",
  "description": "Create an App class responsible for high-level program flow: initialization, parsing arguments, dispatching the file listing operation, and cleanup. This centralizes the logic currently in `main()` into an OOP structure:contentReference[oaicite:4]{index=4}, improving clarity and making the tool's entry point more modular.",
  "goals": [
    "Encapsulate program startup and shutdown in App (e.g., an `App::run()` method) to handle config initialization, CLI parsing, and coordinating other modules (FS, Renderer, etc.).",
    "Move platform-specific init (like enabling Windows terminal ANSI support) and resource loading into App startup sequence.",
    "Loop through input paths and invoke the listing operation for each, as `main()` does, but within App, collecting overall exit status.",
    "Minimal logic in `main()`: it should just create an App instance, call run, and return its status."
  ],
  "scope": [
    "Introduce an `App` class with methods to initialize resources (e.g., calling `init_resource_paths`, loading themes), parse CLI (using the Cli module to populate Config), and perform the directory listing for each path.",
    "Transfer code from `main.cpp` that handles looping over `opt.paths` and calling `list_path` into the App class:contentReference[oaicite:5]{index=5}. In App, use FS and Renderer modules instead of the old `list_path` free function (which will be refactored).",
    "Ensure App uses Config: after CLI parsing, apply configuration like setting active theme (previously done in main with `set_active_theme(scheme)`:contentReference[oaicite:6]{index=6}:contentReference[oaicite:7]{index=7}) and any other global flags.",
    "Handle program exit codes via App: e.g., combine results from processing multiple paths (0 if all OK, 1 for minor issues, 2 for serious, as per VisitResult logic) and return appropriate code."
  ],
  "exclusions": [
    "Don't implement the actual file scanning or output formatting in App (those are handled in FS and Renderer tasks). App should just coordinate those modules.",
    "No changes to CLI argument semantics (App simply uses the Cli module to parse). It also shouldn't alter how help/version are displayed (CLI11 already handles help/exit).",
    "Avoid introducing any platform-specific code in App beyond calling Platform module utilities (keep App logic platform-agnostic)."
  ],
  "architectural_recommendations": [
    "Use App as a high-level controller without storing heavy state. It can contain a Config instance/reference, and perhaps instances of other core classes (or call static interfaces of modules) as needed.",
    "Follow RAII for initialization: e.g., App's constructor or init method can handle calls like enabling VT mode, and ensure resources like theme data are loaded exactly once.",
    "Keep App methods focused and readable: e.g., a `App::processPath(const fs::path&)` helper can handle listing one path (calling FS and Renderer), while `run()` loops over all paths and aggregates results.",
    "Consider testability: App could be written to allow injecting a mock FS or Renderer if needed for tests, or at least structured so its core logic could be invoked in isolation."
  ],
  "cli_considerations": [
    "Integrate with Cli module cleanly: if CLI parsing fails or triggers help/version, ensure App handles that (CLI11 will exit on help by default, which is fine). App should probably catch CLI exceptions if any (e.g., validation errors) and exit with an error code.",
    "After parsing, App should interpret CLI results correctly (e.g., if no paths provided, add current directory as done now, via Config or Cli logic). This ensures behavior parity with original (which adds \".\" when paths are empty:contentReference[oaicite:8]{index=8}).",
    "Use the parsed Config to decide on features: e.g., if Config.git_status is false, skip GitStatus calls; if Config.report is set, ensure to print summary after listing, etc., coordinating with Renderer.",
    "Ensure that multiple path outputs are separated properly (e.g., printing headers or blank lines between directories if required, as current `list_path` does when `opt.paths.size()>1`:contentReference[oaicite:9]{index=9}:contentReference[oaicite:10]{index=10}). App should handle those spacing or delegate to Renderer."
  ]
}
