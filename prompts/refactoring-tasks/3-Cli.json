{
  "title": "Refactor CLI Module (Argument parsing with CLI11)",
  "description": "Reimplement the command-line parsing using the CLI11 library to define all options and arguments in a structured way:contentReference[oaicite:11]{index=11}. This module should translate user inputs into the Config object (using a builder pattern approach:contentReference[oaicite:12]{index=12}) while preserving all current options and behaviors. The result is a robust, easy-to-maintain CLI definition that matches GNU ls semantics where applicable.",
  "goals": [
    "Define all supported options, flags, and positional arguments using CLI11, organizing them into logical groups (e.g., General, Layout, Filtering, Appearance, Information, etc., as in current design).",
    "Map CLI inputs to Config/Options fields: ensure every flag updates the corresponding Config value (e.g., --long -> Config.format = Format::Long) using callbacks or direct binding.",
    "Implement validation and default values through CLI11 (e.g., non-negative integers for width, accepted keywords for --sort, etc.), reproducing the current parser’s rules:contentReference[oaicite:13]{index=13}:contentReference[oaicite:14]{index=14}.",
    "Retain exact compatibility with existing CLI syntax and behavior: all short/long option names, their grouping, and even help text (where feasible) should remain consistent."
  ],
  "scope": [
    "Use CLI11 to set up the CLI parser (CLI::App) with the program description and footer matching the current help output:contentReference[oaicite:15]{index=15}:contentReference[oaicite:16]{index=16}. Include version flag integration (e.g., `--version`) with the current version string.",
    "Port over each option from the legacy parser (found in CommandLineParser::Parse) to CLI11 definitions: for example, `-l/--long`, `-a/--all`, `--color` with choices auto/always/never:contentReference[oaicite:17]{index=17}:contentReference[oaicite:18]{index=18}, etc. Use CLI11 features like `add_flag`, `add_option`, and `CheckedTransformer` for mapping strings to enums:contentReference[oaicite:19]{index=19}:contentReference[oaicite:20]{index=20}.",
    "Ensure mutual exclusivity or dependent relationships are handled (e.g., if `--all` is set, override `--almost-all`, as done in post-processing). This can be done via CLI11 callbacks or after parse adjustments.",
    "Connect the CLI parsing result to Config: e.g., after `CLI::App::parse`, either return a populated Config object or have the parser fill a Config/Options instance member that can be retrieved. Remove the old `Options` global usage in favor of Config."
  ],
  "exclusions": [
    "Do not change the underlying CLI library (still use CLI11 as provided; just configure it).",
    "Do not implement business logic in CLI parsing (e.g., actual listing, output) – only interpret arguments. The execution of listing is handled by App/FS/Renderer.",
    "Auto-generation of README CLI documentation, while mentioned in goals, is outside the direct scope of writing the parser (it can be a follow-up using CLI11 reflection, not part of this immediate refactor task)."
  ],
  "architectural_recommendations": [
    "Use a clear builder pattern for translating options to config:contentReference[oaicite:22]{index=22}. For instance, consider that CLI11 allows binding options directly to variables in Config or a local Options struct which can then be used to construct Config.",
    "Group related options using CLI11 option groups (as done currently with `layout = program.add_option_group(\"Layout options\")`, etc.:contentReference[oaicite:23]{index=23}) to keep the help output organized and matching current layout.",
    "Leverage CLI11 data types: use enums in Config for options like sort order, format, color mode, quoting style, etc. CLI11 can map from string to enum (as seen with CheckedTransformer maps for format and sort:contentReference[oaicite:24]{index=24}:contentReference[oaicite:25]{index=25}) which makes the code more type-safe.",
    "Include robust error handling: utilize CLI11's validation (e.g., custom validators for numeric bounds as used for width:contentReference[oaicite:26]{index=26} and tabsize) to provide user-friendly error messages. This avoids manual error messages and keeps code concise."
  ],
  "cli_considerations": [
    "All existing flags and their combinations should be supported. Cross-check with the current `cli_definition` to ensure completeness (for example, rarely used flags like `-q/--hide-control-chars` or `--hyperlink` must not be forgotten:contentReference[oaicite:27]{index=27}:contentReference[oaicite:28]{index=28}).",
    "Help text and usage should remain informative and accurate. Use the descriptions from the current implementation (which appear to be detailed, including notes for --format choices:contentReference[oaicite:29]{index=29} and footers for environment variables:contentReference[oaicite:30]{index=30}).",
    "Maintain behavior parity: e.g., if no path is given, after parsing, add the current directory as path:contentReference[oaicite:31]{index=31} (this can be done in App or as a final step in CLI parsing). Also ensure that options like `-1` and `-C` override each other correctly (the current parser sets format via callbacks so last one wins).",
    "Verify that the parsing logic sets flags exactly as before: for instance, `-g` implies long format and no owner (show_group false):contentReference[oaicite:32]{index=32}; `-o` implies long format and no group:contentReference[oaicite:33]{index=33}. Such combined effects must be replicated with CLI11 (likely via flag callbacks as in current code)."
  ]
}
