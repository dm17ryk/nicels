{
  "title": "Refactor Theme Module (Color schemes and file icons)",
  "description": "Modularize the theming system for colors and icons into a Theme module. This will manage loading theme files (YAML) for color definitions and icons, and provide lookup functions for other parts of the program to retrieve appropriate symbols and color codes:contentReference[oaicite:84]{index=84}. By doing so, we replace the current global lazy-loading approach with a cleaner design that can handle multiple themes (dark/light) and user preferences.",
  "goals": [
    "Load color palette definitions from YAML (e.g., colors.yaml) and theme mappings for dark and light themes (dark_colors.yaml, light_colors.yaml) at startup, storing the color codes (ANSI sequences) for various item categories (file types, git statuses, etc.).",
    "Load icon mappings from YAML (files.yaml, folders.yaml and their aliases) and provide functions to get the icon for a given filename or extension:contentReference[oaicite:85]{index=85}:contentReference[oaicite:86]{index=86}.",
    "Support switching between at least two themes (dark and light) as determined by Config (e.g., if `--light` specified, use light theme colors). Ensure the active themeâ€™s colors are used throughout the output until changed.",
    "Eliminate global variables for theme data (like g_dark/g_light/g_icons in current code); instead, use a singleton Theme manager or encapsulate state within a Theme class instance. This improves clarity and ensures all theme-related data is initialized in one place."
  ],
  "scope": [
    "Design a `Theme` class or namespace responsible for managing color and icon data. It should load all YAML files from the theme directory (which is configurable via resource paths) on initialization. Use the existing yaml_loader to parse these files into internal maps:contentReference[oaicite:87]{index=87}:contentReference[oaicite:88]{index=88}.",
    "Represent icon sets and color schemes as data structures: e.g., an `IconTheme` struct holding maps for files, folders, file_aliases, folder_aliases:contentReference[oaicite:89]{index=89}, and a `ThemeColors` struct (as currently in colors.h) holding a map of color name -> ANSI code and a `reset` code:contentReference[oaicite:90]{index=90}. The Theme class can contain instances of these for dark and light.",
    "Load default/fallback values: e.g., fallback icons for generic file/folder and some common extensions:contentReference[oaicite:91]{index=91}:contentReference[oaicite:92]{index=92}, and default color name mappings (the code has a built-in palette for basic color names like red, green, etc. in make_default_color_map):contentReference[oaicite:93]{index=93}:contentReference[oaicite:94]{index=94}. These should be applied if YAML files are missing entries, to avoid any missing key issues.",
    "Provide functions: `Theme::getFileIcon(const std::string& filename, bool isExec)` -> returns the icon string and maybe a flag if it's a known type, `Theme::getFolderIcon(const std::string& foldername)`, and `Theme::getColor(const std::string& key)` or similar to fetch color codes by key. Keys might include file categories (\"dir\", \"exe\", \"hidden\", etc.) and git status categories (\"added\", \"modified\", etc., as seen in format_git_prefix using theme.color_or(\"addition\"/\"modification\" etc.):contentReference[oaicite:95]{index=95}."
  ],
  "exclusions": [
    "Do not embed the theme data directly into the binary (unless decided for fallback). Continue to rely on external YAML files in the `yaml/` directory (with the ability to override via NLS_DATA_DIR) for ease of customization.",
    "Do not implement dynamic theme switching at runtime beyond the initial selection. The theme (dark or light) is chosen based on Config at start and remains for the execution (no need for real-time switching).",
    "Not responsible for applying the colors to text in output (Renderer will use the codes provided). Theme just supplies the code sequences (e.g., \"\\x1b[38;2;...m\" strings or other ANSI sequences).",
    "Avoid any platform-specific color handling here; assume ANSI escapes work (Platform module already enables virtual terminal on Windows). Also, no direct printing in Theme."
  ],
  "architectural_recommendations": [
    "Use Singleton pattern if appropriate: a `Theme::instance()` could hold the active theme data for global access. Since theme info might be used widely (FS for icons, Renderer for colors), a singleton can simplify usage. However, ensure it's initialized explicitly (e.g., Theme::init(Config)) to know which scheme to load, rather than relying on static init order.",
    "Leverage RAII for loading: perform all file reads at initialization (App startup) to avoid repeated file I/O. The current code does lazy loading on first usage:contentReference[oaicite:96]{index=96}:contentReference[oaicite:97]{index=97}; in refactor, consider loading both dark and light themes upfront (cost is minor) and just pick active, to simplify logic and ensure all needed data is ready.",
    "Keep data retrieval efficient: use unordered_map lookups for icon and color queries. The volume of keys is moderate (file extensions, a few dozen; color keys similar), which is fine. If needed, normalize keys (e.g., lowercase file extensions as done in current code with `StringUtils::ToLower`) on load to avoid doing it on every query.",
    "For maintainability, clearly separate icon logic and color logic in the code (possibly different source files or at least different classes) even if they share the Theme namespace. They serve different purposes (one maps file names to symbols, the other maps item types to color codes), so clarity in implementation is key."
  ],
  "cli_considerations": [
    "`--light` or `--dark` flags in CLI set the desired color scheme:contentReference[oaicite:98]{index=98}. The Theme module should respond to this by loading or activating the appropriate theme (light or dark) as default. If neither is specified, default to dark (as current code does, g_active = &g_dark by default):contentReference[oaicite:99]{index=99}:contentReference[oaicite:100]{index=100}.",
    "`--no-color/--color=never`: If the user opts to disable color, the Theme module may still load colors, but Renderer will ultimately decide not to use them. Optionally, Theme could provide an easy way to fetch a color or an empty string if no_color is true, but that logic can also live in Renderer by simply not calling Theme for colors when disabled.",
    "`--no-icons`: Similarly, if icons are disabled, FS/Renderer will not prepend icons. The Theme module can still load icon data, but the decision to use or ignore it lies elsewhere. Ensure that when icons are disabled, nothing breaks (e.g., FS should simply not set FileInfo.icon, or Renderer should skip outputting it).",
    "Make sure any environment variable override (like NLS_DATA_DIR for custom theme location) is honored. The resources initialization (resource_dirs) already handles adding `./yaml` and paths around the executable:contentReference[oaicite:101]{index=101}:contentReference[oaicite:102]{index=102}. Theme module should use `find_resource(<file>)` (from resources.cpp) to locate each YAML file so that this logic is centralized and consistent."
  ]
}
