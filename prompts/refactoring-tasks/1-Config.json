{
  "title": "Refactor Config Module (Singleton for runtime configuration)",
  "description": "Introduce a Config class to hold all runtime configuration options (previously in struct Options). This singleton-like module will centralize settings from CLI and environment, providing a single source of truth for other components:contentReference[oaicite:0]{index=0}. It eliminates scattered global state and ensures configuration is accessed via a controlled interface.",
  "goals": [
    "Encapsulate all CLI options and derived settings into a Config class (minimal Singleton):contentReference[oaicite:1]{index=1}.",
    "Eliminate use of global variables for configuration; use dependency injection or explicit access through Config instance.",
    "Initialize Config from CLI parser results and environment (e.g., default QUOTING_STYLE or LS_COLORS if applicable).",
    "Preserve existing behavior for all options (defaults, interactions, environment overrides) while using modern C++ constructs."
  ],
  "scope": [
    "Define a `Config` class (in Config.h/Config.cpp) to store flags and settings (fields corresponding to all members of the old Options struct).",
    "Modify CLI parsing (CommandLineParser) to populate the Config instance instead of returning a separate Options object (e.g., via a builder pattern or by returning Config).",
    "Update all code that uses `Options` (main, list_path, etc.) to obtain values from Config (either by passing a reference or via Config singleton access).",
    "Include environment-derived settings in Config (for example, apply QUOTING_STYLE env var before/after CLI parse as currently done:contentReference[oaicite:2]{index=2})."
  ],
  "exclusions": [
    "No changes to how CLI options are defined or what options exist (CLI interface remains the same).",
    "Detailed theme or color configuration is handled in Theme module (Config may just store a selected theme name or flag like `color_theme`).",
    "Logging/verbose output configuration (if any) is outside this task unless needed for Config completeness."
  ],
  "architectural_recommendations": [
    "Use the Singleton pattern for Config (single global instance) only for the scope of runtime config:contentReference[oaicite:3]{index=3}. Keep it minimalâ€”just store state and provide getters/setters. Avoid adding unrelated functionality to Config.",
    "Prefer dependency injection: wherever possible, pass Config (or relevant const refs) into constructors or functions instead of accessing globally, to reduce tight coupling.",
    "Ensure Config is initialized early (e.g., in App startup) and remains immutable or const to other modules after initialization to avoid unintended modifications.",
    "Implement Config in modern C++ style: use `std::optional` for optional values, `std::string_view` for read-only string refs, and strongly typed enums for option values (e.g., for sorting mode or color scheme) instead of raw ints."
  ],
  "cli_considerations": [
    "Preserve all current CLI options and defaults; the Config fields should directly mirror these options (e.g., Config::all, Config::long_listing, etc.).",
    "Ensure that setting `--light` or `--dark` in CLI updates Config's theme selection (e.g., a ColorScheme enum) so that Theme module can use it.",
    "Implement handling of `--color=auto`: if output is not a terminal, Config should reflect that colors will be disabled (e.g., set a flag no_color) based on platform check (tty detection).",
    "Maintain backward compatibility: any scripts or tests relying on specific combination of flags should produce identical results via the new Config-managed approach."
  ]
}
