{
  "title": "Refactor Formatter Module (Size, time, and permission formatting)",
  "description": "Extract and modernize the utility functions that format file sizes, times, and permissions into a Formatter module. These will provide reusable, side-effect-free functions or classes to convert raw file metadata into human-readable strings for output:contentReference[oaicite:103]{index=103}. By isolating these concerns, we avoid duplicating logic and ensure consistency across the codebase.",
  "goals": [
    "Implement a `SizeFormatter` that can output file sizes in human-readable form (e.g., using decimal or binary prefixes) or raw bytes, depending on options (– this corresponds to whether `--bytes` is set or block size options).",
    "Implement a `TimeFormatter` to format timestamps according to the specified `time_style` (e.g., full-iso, long-iso, locale, etc.), including handling of `--full-time` and custom format strings if any (like +FORMAT).",
    "Implement a `PermissionFormatter` that takes a file’s mode (or FileInfo attributes) and produces a string like `rwxr-xr-x`, possibly colorizing it (via Theme) for special file types as in current output (e.g., directory vs file).",
    "Provide these formatters as lightweight, possibly header-only utilities (since they may be called per file in hot loops), ensuring they use modern C++ features (`constexpr`, `<format>`, `<chrono>` formatting) for performance and clarity."
  ],
  "scope": [
    "Refactor existing formatting functions: e.g., `GetSizeFormatter().FormatHumanReadable()`:contentReference[oaicite:104]{index=104}, `GetTimeFormatter()`, `GetPermissionFormatter()` are accessed via singletons in current code. Transform these into either static functions or instantiable classes in Formatter module.",
    "SizeFormatter: support formatting in at least two modes – raw bytes (no suffix, just number) and human-friendly (with K, M, G, etc.). The logic for interpreting block size (like --block-size and -h in GNU ls) partly exists in parsing (ParseSizeSpec) and in output (format_report_size uses either bytes or human-readable):contentReference[oaicite:106]{index=106}. Consolidate that so SizeFormatter can be told what unit or base to use.",
    "TimeFormatter: utilize `std::format` with chrono or `std::put_time` to format times. The styles like `locale`, `iso`, `full-iso` might need pre-set format strings (e.g., full-iso corresponds to a specific `strftime` pattern). Use the `Config.time_style` to decide the format. Also consider the current logic that uses environment variable TIME_STYLE (mentioned in help text) – ensure defaults match if TIME_STYLE env is set (could be handled in Config).",
    "PermissionFormatter: take information from FileInfo (which includes booleans like is_dir, is_symlink, etc., and possibly mode if available). It can reconstruct the permission string (the code currently likely uses `std::filesystem::perms` from status). Implement this by mapping bits to `rwx` and special file indicators (d for directory, l for symlink, etc.). Also, incorporate the `--numeric-uid-gid` and `--no-group` options effect: those actually affect owner/group output, which might be handled outside PermissionFormatter, but ensure not to conflict."
  ],
  "exclusions": [
    "Do not duplicate functionality available in the standard library: for instance, if `<format>` with chrono can produce the needed timestamp format, use it rather than custom code (except for complex relative formats which might not apply here).",
    "Do not handle localization beyond what's requested (the 'locale' time_style presumably means use the current C locale’s format – we can achieve that via `std::locale` and `std::put_time` if needed). Internationalization of day/month names is out of scope except via system locale.",
    "No printing to console in these utilities – they should return strings. The Renderer will append or insert these into the output.",
    "Avoid heavy dynamic allocation for each formatted element. For example, reuse static buffers or preallocate strings if possible for performance, since these functions may be called thousands of times. (However, be careful with static buffers in multi-thread context – likely not an issue here.)"
  ],
  "architectural_recommendations": [
    "Consider making these utilities static or singleton-less: e.g., define `Formatter::formatSize(bytes, config)` that returns a string, rather than requiring an object. The original code’s use of singletons (GetSizeFormatter()) was to avoid re-creating locale facets repeatedly. In C++23, this might not be a big issue, but you could still cache expensive constructs if needed (like a prepared list of size suffixes).",
    "Use `constexpr` and compile-time tables where possible – e.g., a table of file permission characters for each file type bit, or powers of 1024 for size calculation can be `constexpr`.",
    "Implement RAII only if needed for resource acquisition in formatting (perhaps a locale imbuer). Most likely not needed, as formatting uses standard library which manages locale facets itself.",
    "Keep interfaces decoupled: Formatter functions should take basic inputs (numbers, timestamps, FileInfo or `fs::perms`) and not depend on global Config. If needed, pass Config or specific flags to them (for instance, pass a bool for numeric_uid_gid into the function that formats owner/group names). This makes them more testable and reusable."
  ],
  "cli_considerations": [
    "`--bytes` (aka --no-human-readable): ensures sizes are printed as exact bytes without K/M suffix. Our Formatter should check Config.bytes and simply return `std::to_string(size)` in that case:contentReference[oaicite:107]{index=107}.",
    "`--block-size=SIZE`: If this is set, listing output sizes should be scaled to that block size (like `du` command style). The code stores Config.block_size and whether block_size_specified. Formatter should use those: if specified, and showing file sizes in long list, possibly divide size by block_size and show maybe the suffix if block_size_show_suffix is true. The current code’s `format_size_value` and `block_display` handle this:contentReference[oaicite:108]{index=108}:contentReference[oaicite:109]{index=109} – integrate that logic.",
    "`--time-style`: Recognize the values \"full-iso\", \"long-iso\", \"iso\", \"locale\" and implement corresponding formats. E.g., \"full-iso\" might be `%Y-%m-%d %H:%M:%S.%N %z`. \"locale\" might use `std::chrono::current_zone()` or system locale time format. Ensure that if TIME_STYLE env is set and no flag given, Config.time_style reflects it (the CLI parser already checks an env for time style perhaps).",
    "`-n/--numeric-uid-gid`: If this is set, the output should show numeric UIDs and GIDs instead of names. FileOwnershipResolver already stores numeric strings in FileInfo (owner_numeric, group_numeric). Ensure Renderer uses those when numeric flag is on. PermissionFormatter might not directly handle this (since it's more about rwx string), but it's related to how we display owner/group in long format (which Renderer will handle by picking appropriate field from FileInfo).",
    "`-p/--indicator-style=slash`: This is about appending a slash to directories. That logic is simple (if entry is dir, add '/'). It could be done in Formatter (like a function `Formatter::appendIndicator(FileInfo)`), or directly in Renderer. Currently it's done in base_display_name (if opt.indicator == Slash and is_dir):contentReference[oaicite:110]{index=110}. We should preserve that by some means (maybe a small utility in Formatter or just handle in Renderer)."
  ]
}
