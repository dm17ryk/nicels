{
  "title": "Refactor FS Module (Filesystem traversal and file info gathering)",
  "description": "Isolate directory traversal and file metadata retrieval into an FS module. This component will handle reading the filesystem (directories, files, symlinks), applying filters (like hidden files, type filters), and populating structures with file info. By centralizing this logic:contentReference[oaicite:34]{index=34}, we remove it from main and improve maintainability, while using C++23 filesystem features for clean, efficient code.",
  "goals": [
    "Implement a clear abstraction for scanning directories and files (e.g., a function or class method to collect entries from a given path, optionally recursively for tree view).",
    "Gather all relevant metadata for each file entry: type (file/dir/link), size, permissions, timestamps, symlink target, etc., encapsulated in FileInfo objects.",
    "Apply filtering based on Config: e.g., skip hidden files unless `--all`, skip `.` and `..` unless `--all`, honor `--almost-all`, `--ignore-backups`, `--ignore`/`--hide` patterns, and directory/file-only flags (`-d/--dirs` or `-f/--files`) during the scan:contentReference[oaicite:35]{index=35}:contentReference[oaicite:36]{index=36}.",
    "Handle errors gracefully: if a directory cannot be opened or read, report error (consistent with current behavior using `report_path_error`) and mark the visit result as minor/serious as appropriate."
  ],
  "scope": [
    "Create an `FS` namespace or class (e.g., `FileScanner`) that provides functions like `scanDirectory(const fs::path&, const Config&, bool isTopLevel)` -> returns list of entries (or a tree structure for recursion).",
    "Utilize `std::filesystem` iterators with `std::error_code` for efficient, exception-free directory iteration:contentReference[oaicite:37]{index=37}. For example, use `fs::directory_iterator` and check `iter_ec` instead of throwing on failures.",
    "Populate each `Entry`/`FileInfo` with data: use `directory_entry` methods (exists, is_directory, file_size, last_write_time) to fill attributes, falling back to explicit `fs::status` or platform APIs when needed (e.g., for symlinks on Windows using `SymlinkResolver`):contentReference[oaicite:40]{index=40}:contentReference[oaicite:41]{index=41}.",
    "Integrate existing helper components: call `FileOwnershipResolver::Populate` to get owner/group and inode info for each entry (this handles both POSIX and Windows specifics):contentReference[oaicite:42]{index=42}:contentReference[oaicite:43]{index=43}. Also use `PermissionFormatter` or equivalent to determine executable status on POSIX (as done in `is_executable_posix`):contentReference[oaicite:44]{index=44}."
  ],
  "exclusions": [
    "Do not implement Git status here – after FS collects entries, the GitStatus module will be invoked separately to annotate them.",
    "Do not perform output formatting or sorting in FS. FS should return unsorted data; sorting (by name, time, size, etc.) is handled by Renderer or a separate step after FS (as in current code where `sort_entries` is called after collect_entries):contentReference[oaicite:45]{index=45}.",
    "Avoid direct console output in FS (no printing). Error messages should be conveyed via returned status codes or exceptions so that the App/Renderer can handle reporting uniformly (for now, can use the same `report_path_error` approach internally).",
    "Recursion for tree view (`--tree`) can be handled here or in a higher-level function, but ensure it’s within the FS domain. However, presenting the tree (printing branches) is Renderer’s job; FS just needs to produce a hierarchical data structure if needed."
  ],
  "architectural_recommendations": [
    "Consider splitting responsibilities for clarity: e.g., implement a recursive helper for tree traversal. Current code uses `build_tree_items` to produce a nested vector structure for tree view:contentReference[oaicite:46]{index=46} – you can mirror that functionality in FS, perhaps returning a custom Tree structure (nodes with children).",
    "Use RAII and smart pointers if any resource acquisition is needed (though in filesystem iteration, not much explicit resource management occurs beyond file handles that the OS manages).",
    "Minimize system calls: e.g., call `directory_entry.status()` once and reuse results rather than calling separate `is_directory`, `is_symlink` etc. The current code does multiple checks with `fs::is_*` and might benefit from using a single `status` or `symlink_status` to derive all info, to reduce overhead.",
    "Ensure thread-safety for future-proofing (though currently single-threaded). No static mutable data in FS – each scan operation works off inputs and produces outputs without side effects, except via returned error codes."
  ],
  "cli_considerations": [
    "Honor `--dereference (-L)` in FS: if set, for symlinks, FS should retrieve the target's info (size, type) instead of the symlink itself:contentReference[oaicite:47]{index=47}:contentReference[oaicite:48]{index=48}. The code snippet shows that if dereference is true and entry is symlink, it stats the target and updates FileInfo accordingly – preserve this behavior.",
    "Implement `-d/--dirs` and `-f/--files` filtering: if `dirs_only` is true, include directories and exclude regular files; if `files_only` is true, include files and exclude directories:contentReference[oaicite:49]{index=49}. Ensure that in tree mode, `--dirs` likely implies not descending into subdirs (the current logic might already skip adding children if not needed).",
    "Include `.` and `..` entries when required: current logic adds them at top of directory listing if `--all` is set:contentReference[oaicite:50]{index=50}. Keep this in FS: e.g., after reading a directory, optionally prepend `.` and `..` entries if needed (with proper FileInfo indicating directories).",
    "Pattern filtering: implement shell-style pattern matching for `--ignore` and `--hide`. The code uses functions like `matches_any_pattern` (with wildcard and character classes). Reuse or move those utilities into FS (or a helper class) so that before adding an entry, you check against ignore patterns (skip if match) and hide patterns (skip if match *and* not showing all). This preserves behavior of ignoring backup files (~) if `--ignore-backups`, etc."
  ]
}
