{
  "title": "Support Installable Package Configuration (Global & User YAML Paths)",
  "repo_state": "All changes committed. Work off the latest master branch.",
  "vcs_commands": [
    "git checkout master",
    "git pull --rebase",
    "git submodule update --init --recursive"
  ],
  "description": "Update the `nicels` tool to support loading its YAML configuration files from standard installation directories on each platform, enabling it to run as an installable package (not just from the source folder). Currently, `nicels` only searches for its YAML files in a few locations relative to the binary or working directory:contentReference[oaicite:0]{index=0}:contentReference[oaicite:1]{index=1}, which is insufficient when the program is installed in a fixed location. This task will extend the resource path logic to include system-wide default paths (e.g. Program Files on Windows, `/etc/dm17ryk/nicels/yaml` on Linux) and a user-specific config directory (e.g. under the user's home). The application should load default theme/icon settings from the global YAML files installed with the program, then load any user-provided YAML files (if present in the user config dir) to override or augment those defaults. This allows per-user customization of colors and icons without modifying the global installation files, and ensures `nicels` can locate its resources when run from an installed location.",
  "goals": [
    "**Expand Resource Search Paths for Installation:** Modify the resource path initialization to include new default directories for configuration. On Windows, ensure the directory containing the installed executable (e.g. `Program Files/.../nicels/yaml`) is already searched (currently handled via exe path) and add the user's config folder (for example, `%APPDATA%` or home directory) under `.nicels\\yaml`. On Unix-like systems, add the system-wide config directory `/etc/dm17ryk/nicels/yaml` for global defaults, and the user’s `$HOME/.nicels/yaml` for overrides. Use platform checks (`#ifdef _WIN32`) to differentiate these paths:contentReference[oaicite:2]{index=2}.",
    "**Load Global then User YAML Files:** Implement a loading strategy where for each YAML config file (colors, icons, aliases, etc.), the program first loads the global version then loads the user version (if it exists), rather than stopping at the first found file. Currently, the code finds a single file per config name:contentReference[oaicite:3]{index=3}:contentReference[oaicite:4]{index=4}. Update this so that after loading the default values from the global YAML, it then looks for a corresponding user YAML in the user directory and merges those values on top. This ensures user-defined entries override the global defaults without needing to duplicate the entire file.",
    "**Preserve Default Behavior if User Files Missing:** The program should continue to operate with built-in defaults and global files when no user config is present (or if the user hasn’t created a personal YAML). In other words, user YAML files are optional. If they don’t exist, `nicels` should simply use the global configuration (or fallback constants compiled in) with no errors or interruptions:contentReference[oaicite:5]{index=5}. This goal ensures backward compatibility and that a fresh install works out-of-the-box with the provided default configs.",
    "**Maintain Environment Override Priority:** Retain the existing `NLS_DATA_DIR` environment variable override as the highest priority for resource files. If this env var is set, `nicels` will look in that directory first for YAML files:contentReference[oaicite:6]{index=6}, potentially bypassing the standard global/user lookup. The new search paths (global `/etc` or user folder) should come into play only when not using `NLS_DATA_DIR`, or as fallback if a particular file is not found in the override directory. Document how the environment override interacts with the new path logic (likely, it overrides both global and user paths).",
    "**Reload Config on Startup (no persistent cache):** Ensure that the YAML configuration is loaded fresh each time the application starts, so any changes to user config files take effect on the next run. The current design already reloads configs on each invocation (e.g. `Theme::ensure_loaded` reads files on startup):contentReference[oaicite:7]{index=7}; we must preserve this behavior. There is no need to implement live-reloading while the program is running—just confirm that each new execution of `nls` picks up the latest file contents from the global and user directories.",
    "**Continue support DEV mode where yaml in source tree is used:** When running from the build or source directory (e.g. during development), the existing behavior of finding YAML files in `./yaml/` relative to the current working directory or executable should remain unchanged. This allows developers to test changes to themes and icons without needing to install the program. The new paths primarily affect installed usage, while the local `yaml/` folder remains a priority when present in the working directory."
  ],
  "scope": [
    "Modify `ResourceManager::initPaths` (in **resources.cpp**) to add the new directories. After the existing entries (env var, `cwd/yaml`, and exe-relative paths):contentReference[oaicite:8]{index=8}:contentReference[oaicite:9]{index=9}, include platform-specific defaults: \n  - **On Linux/macOS:** call `addDir()` for `/etc/dm17ryk/nicels/yaml` (global config) and for `$HOME/.nicels/yaml` (user config directory). You can obtain `$HOME` from the environment (`getenv(\"HOME\")`). Ensure to handle the case where HOME might not be set (not common, but use an empty string check).\n  - **On Windows:** determine the user data directory. For example, use the `APPDATA` environment variable (which points to the Roaming profile directory) or `USERPROFILE` as a base. Construct a path like `%APPDATA%` + `\\Nicels\\yaml` or `%APPDATA%` + `\\.nicels\\yaml` (the exact folder name can be \".nicels\" to mirror Unix, or just \"nicels\"). For consistency with the prompt, use `.nicels\\yaml` in the user’s roaming AppData. Add this directory via `addDir()`. (The global path on Windows is already covered by adding the exe’s directory and parent directory.) \nUse `#ifdef _WIN32` to wrap the Windows-specific code, and an `#else` for Unix. After this change, `ResourceManager::directories_` will include the new paths (e.g. `/etc/...` and home) in addition to the current ones.",
    "Adjust the logic in **Theme::load_theme_file** (in **theme.cpp**) to load and merge two files for each theme color config. Currently it loads one YAML (if found) into a ThemeColors object on top of a fallback theme:contentReference[oaicite:10]{index=10}. Change this so it attempts to find *both* the global and user file. For example, for `dark_colors.yaml`: first find and load the global `dark_colors.yaml` (likely found in the `/etc/...` or exe directory), then check if a user copy of `dark_colors.yaml` exists in `$HOME/.nicels/yaml` (or `%APPDATA%\\.nicels\\yaml` on Windows). If the user file exists, parse it and override the corresponding entries in the ThemeColors. The `ThemeColors::set` method can be used to update values. This way, the final color theme is a mix of global defaults plus user overrides. If the global file isn’t found but the user file is, simply load the user file on top of the fallback (which is already in place).",
    "Similarly, update **Theme::load_icons** to merge user config for icons. The code currently merges each of the icon maps from a single found YAML file (files, file_aliases, folders, folder_aliases) onto the defaults:contentReference[oaicite:11]{index=11}:contentReference[oaicite:12]{index=12}. Introduce an additional step: after merging the global YAML (if found) for each category, attempt to find the user’s YAML file for that category and merge it as well. For example, after processing `files.yaml` from the global path, look for `$HOME/.nicels/yaml/files.yaml` and if it exists, call `YamlLoader::LoadSimpleMap` on it and then `ThemeSupport::MergeMap(icons_.files, userMap)`. Do this for each of the four YAML config files (files, folders, file_aliases, folder_aliases). Use the same `lowercase_keys=true` and `lowercase_values` as the global merge does, so that key normalization remains consistent. This will ensure any icons or aliases defined in the user YAML override the global settings.",
    "Ensure that the search order in `ResourceManager` does not break existing behavior. The global path (Program Files or `/etc/...`) should be added **before** the user path in the directories list, so that `find()` will return the global file if one exists, rather than the user file. This is important because we want to load the global file first. The user file will be loaded in a second step explicitly. Because `ResourceManager::find` returns only the first match:contentReference[oaicite:13]{index=13}, our code will likely call it once (to get the global file path) and then separately construct the user file path. We might not rely on `find()` for the user file at all, instead using a known user directory path (from the initPaths list or environment) to build the filename. For example, after loading global `folders.yaml`, do something like: if the user config directory was added, construct `userPath = \"<user_config_dir>/folders.yaml\"` and check `std::filesystem::exists` on it (or iterate through ResourceManager directories to specifically find a match in the user dir). This approach avoids confusion over which file `find` returned and ensures both files are considered.",
    "Maintain the built-in fallback defaults. The code defines a `MakeFallbackTheme()` and `MakeFallbackIcons()` which provide baseline colors and icons in case no YAML data is found:contentReference[oaicite:14]{index=14}. These should remain unchanged. Our changes should complement them: if neither global nor user YAML provides a particular setting, the program continues to use the compiled fallback. Do not add errors if files are missing; the silent fallback behavior is intentional. Also, do not change how missing entries in YAML are handled – e.g., if a key is in global but not in user, the global value stays in effect (since user YAML merges on top). We just need to ensure that merging logic correctly leaves unspecified keys untouched and overrides ones that are specified by the user."
  ],
  "exclusions": [
    "**No YAML Format Changes:** Do not alter the format or structure of the YAML configuration files. The task is purely about where the files are located and how they are loaded, not the content. Users should not have to change their YAML syntax; a user override file will have the same format as the global file and define the same keys.",
    "**No New Config Names:** Do not introduce additional config file names or lookup patterns beyond those already in use (colors.yaml, dark_colors.yaml, light_colors.yaml, files.yaml, folders.yaml, file_aliases.yaml, folder_aliases.yaml). The code should continue to load exactly these files (plus any future ones already planned) from the new locations. We are simply extending the search to new directories, not adding new types of configuration.",
    "**Non-Interactive & Backward Compatible:** The application should not prompt or require any user input regarding config files. If the user-specific files don’t exist, the program should quietly proceed with defaults. Also, ensure that in a development scenario (running from the build tree or source checkout), the presence of `/etc/nicels` files or user files doesn’t override the developer’s intended config. The existing search order (env -> local yaml folder -> etc.) combined with merging means that, for example, running `nls` from its source directory (which has a `yaml/` folder) will use those local YAML files preferentially:contentReference[oaicite:15]{index=15}, maintaining the developer experience. The new paths primarily affect installed usage.",
    "**No Runtime Reloading:** This task doesn’t involve implementing live reload of configuration while `nls` is running. The focus is on loading from new paths at startup. Users who change their YAML files will need to restart `nls` to see the changes, which is acceptable. Avoid any complicated file watchers or periodic reload logic – it’s not needed here.",
    "**Don’t override env override:** If `NLS_DATA_DIR` is set, do not ignore it or change its meaning. We are not deprecating it. It should still short-circuit the search to that directory only (except possibly still allowing user overrides, but for simplicity, it's fine that if env is set, it takes precedence over both global and user paths entirely). The new logic should integrate without altering how a custom data directory is used."
  ],
  "architectural_recommendations": [
    "Use the facilities of `<filesystem>` to construct and check paths. For example, after determining the user config directory (via environment or home directory), you can construct the full path to a YAML file with `std::filesystem::path userDir = ...; userDir /= \"files.yaml\";` and then test `exists(userDir)`. This is safer than string concatenation and handles path separators automatically. Similarly, continue using `std::filesystem::exists` with an `std::error_code` to avoid exceptions when checking for file presence:contentReference[oaicite:16]{index=16}.",
    "Encapsulate the platform-specific path retrieval. It might be worth writing a small helper inside `initPaths` or a separate function to get the user config directory. On Windows, consider using `APPDATA` (Roaming) for config as it is the conventional place for per-user application data. Using `HOME` on Windows (if present in some environments) is less standard. On Linux, `$HOME` is standard for user config; though XDG standards might suggest `$HOME/.config/nicels`, the task explicitly uses `.nicels` in home. Follow the given specification, but perhaps leave a comment noting where these paths are defined for easy adjustment if needed in the future.",
    "When merging configurations, be mindful of case-insensitivity and duplicates. The code already lower-cases keys for maps to ensure consistency (notice the `lowercase_keys=true` parameter and use of `ToLower` in MergeMap):contentReference[oaicite:17]{index=17}. Continue that practice for user files. This way, a user defining an icon for \"PNG\" or \"png\" will correctly match the global key format. Also, merging via `unordered_map` insertion will naturally override duplicates. Make sure to load the YAML files in a deterministic order (global then user) so overrides apply correctly.",
    "Test the new behavior thoroughly on each platform. For example, on Linux: install the program (or simulate an install by creating `/etc/dm17ryk/nicels/yaml` with the YAML files). Run `nls` and confirm colors/icons are applied (meaning it found the global files). Then create a `~/.nicels/yaml/` directory with a small override (e.g., change the color for \"dir\" or icon for a certain extension) and run again; verify the override takes effect. On Windows: place the YAML in the installation directory and one in the AppData path and do a similar test. Ensure that if the user YAML is malformed or missing keys, it doesn’t break loading of other settings – the merge should simply skip those or leave defaults intact.",
    "Keep performance and complexity in mind. The YAML files are small, and loading two files instead of one is trivial for performance. Avoid premature optimization like caching the combined result on disk – just reading the files on each run is fine (and ensures current data). The changes should be implemented with clarity rather than micro-optimizations. For instance, adding a couple of `exists()` checks and merges will not noticeably slow down the tool, but will greatly improve flexibility. Prioritize clear structure: it should be obvious which paths are being added and in what order, so future maintainers can adjust paths if needed (for instance, adding an XDG path on Linux later). Comments in code explaining the load order (\"global then user override\") are recommended."
  ],
  "cli_considerations": [
    "Although this feature is mostly internal, it affects how users can customize `nls`. After implementation, update user-facing documentation (README or help text if any) to mention the new config file locations. For instance, instruct users that they can put overrides in `~/.nicels/yaml/` (or the equivalent on Windows) instead of editing system files. This empowers advanced users to tailor the output (colors/icons) to their preference safely.",
    "Check that error messaging (if any) for missing resource files remains appropriate. Currently, if a YAML file is not found, `nls` does not throw an error; it just uses defaults. Continue this approach. The CLI should not start outputting warnings about missing user files, for example. The silent fallback is intentional to not spam the user every time they run `ls`. Only in debug or verbose modes might it be worth logging, but this task does not require adding such logging unless it's already present (and it doesn’t appear to be).",
    "When the program is installed, ensure that it indeed includes the YAML files in the expected global location. For example, packaging scripts or CMake install rules should copy the YAML files to `/etc/dm17ryk/nicels/yaml` on Linux (likely requiring root permission during install) or to the installation directory on Windows. If this is not already handled, note that it must be part of the installation process (though implementing the installation script is outside this task’s direct scope, the code should assume those files are there). From the CLI perspective, as long as the files are placed correctly, the tool will find them thanks to our path setup.",
    "Consider if any CLI option interacts with themes or icons (for example, `--no-color` or `--no-icons`). Those should still work as before, just turning off color output or icon display. Our changes don’t affect runtime option parsing, but we should ensure that if a user disables icons, it doesn’t matter what the YAML says – the program should skip showing them. This remains unchanged, but worth testing that nothing in the merge logic inadvertently breaks these flags (it shouldn’t, since those flags just prevent using the loaded icons/colors when printing).",
    "Finally, test scenarios where a user might have partial overrides. For example, the user only creates `folders.yaml` in their `~/.nicels/yaml` and nothing else. `nls` should still load all other settings from the global files, and just override folder icons from the user file. The CLI output (file listings) should reflect this combination: everything default except what was specifically overridden. This incremental override ability is a key benefit of the feature, and from the user’s perspective, it should \"just work\" without any special syntax or commands."
  ]
}
