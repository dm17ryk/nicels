{
  "title": "Create Linux Installer Packages for nicels (DEB & RPM for nls CLI)",
  "repo_state": "All changes committed. Work off the latest master branch.",
  "vcs_commands": [
    "git checkout master",
    "git pull --rebase",
    "git submodule update --init --recursive"
  ],
  "description": "With the Windows installer in place, the next step is to distribute **nicels** (`nls`) on Linux via native **Debian (.deb)** and **Red Hat (.rpm)** packages. We need to build installer packages that meet all requirements: they should support both system-wide installation (for all users, requiring root) and single-user installation (no root needed), bundle the necessary YAML configuration files, place the `nls` executable in the user’s PATH, and handle upgrades or downgrades cleanly. We will leverage CMake’s **CPack** to automate the creation of these packages, similar to how the NSIS installer was integrated for Windows. The packaging must correctly declare all dependencies so that installing the .deb or .rpm pulls in any required libraries. Additionally, because .deb and .rpm don’t inherently offer an interactive choice for per-user vs system install, we’ll provide an alternative method (such as a user install script or archive) to allow non-privileged users to install `nls` into their home directory. By the end of this task, Linux users should be able to install **nicels** easily either via their system package manager or with a manual method, and the program should locate its config files in the standard directories (`/etc/dm17ryk/nicels/yaml` for global defaults and `~/.nicels/yaml` for user overrides) as implemented previously. Below we outline the goals, implementation steps, and considerations for creating the Debian and RPM packages.",
  "goals": [
    "**Support System-wide and Per-User Installation:** Provide packaging options for both root-based installation (system-wide for all users) and non-root installation for a single user. For system installations, the .deb/.rpm should install files to standard system locations (e.g. `/usr/bin` for the binary, `/etc/dm17ryk/nicels/yaml` for config). For a user-only install (no sudo), supply a means (script or archive) to install the `nls` binary and config files under the user’s home (e.g. `~/.local/bin` for the binary and `~/.nicels/yaml` for configs). This ensures even users without admin rights can use **nls**.",
    "**Include YAML Configuration Files:** All default `.yaml` config files (themes, colors, icons, aliases, etc.) must be packaged and installed in the correct directory. System installations should place these files under `/etc/dm17ryk/nicels/yaml` (the global config directory). The program’s existing search paths will find them there at runtime. For a user installation, the same set of YAML files should be placed in the user’s `~/.nicels/yaml` directory. Packaging these files guarantees that `nls` has access to its necessary theme and icon configurations out-of-the-box, just as it does when run from the source repository.",
    "**Add `nls` to the PATH:** The installation process should ensure the `nls` command is readily accessible from the shell. In a system-wide install, this means placing the `nls` binary in a directory already on the PATH (such as `/usr/bin`). In a per-user install, the binary should be placed in a standard user-local bin directory (e.g. `$HOME/.local/bin`) and the user informed if they need to add it to their PATH. The goal is that after installation, users can open a new terminal and run `nls` without additional setup. (For .deb and .rpm installed as root, this is automatic via `/usr/bin`. For a home install, we may rely on the conventional presence of `~/.local/bin` in PATH or instruct the user to add it.)",
    "**Handle All Runtime Dependencies:** The Linux packages must declare any libraries or tools that `nls` requires at runtime so that package managers can resolve them. We will auto-detect shared library dependencies of the `nls` binary and include them in the package metadata. For example, if `nls` links to OpenSSL (libssl and libcrypto) or other libraries, the .deb’s control file should list those as dependencies, and the .rpm should have corresponding `Requires` entries. This ensures that installing the package also installs (or at least checks for) everything needed to actually run `nls` on the target system.",
    "**Upgrade/Downgrade Friendly:** Installing a new version of nicels via the package should seamlessly replace any older version, and downgrading (installing an older package over a newer one) should also work without leaving broken files. Use consistent package naming and versioning so that the system’s package manager recognizes new versions and handles upgrades automatically (e.g., the Debian package name might be `nicels` with a version, so `dpkg -i` or apt upgrade will overwrite the old one). Configuration files should be handled carefully: global config in `/etc` should be updated to the new version’s defaults on upgrade (while preserving any user-specific overrides in home), and in a user-only install scenario, any existing user config files should be backed up before installing the new ones to avoid overwriting user customizations without warning. The goal is that users can upgrade or downgrade by installing the desired package and not worry about manually uninstalling or cleaning leftover files.",
    "**Provide Binary and Source Packages:** Generate two forms of deliverables for nicels: a binary package (the installable .deb/.rpm, plus possibly a tarball for manual installs) and a source package. The **binary packages** contain the compiled `nls` executable and all necessary support files and metadata. The **source package** (or source distribution) should bundle the project’s source code (including submodules) and include instructions or metadata for building it. In a Debian context, this would mean providing the upstream source tarball and possibly a debian control file with Build-Depends; for our purposes, it can be a tarball of the source and documentation of build requirements. Ensure that the source package lists all packages needed to compile and package `nls` (e.g. compilers, CMake, Ninja, OpenSSL dev libraries, etc.), so that developers or maintainers can easily rebuild the binary. This caters to open-source distribution norms and lets users compile nicels themselves if desired.",
    "**Update Documentation:** Reflect the new Linux installation options in our documentation. For example, add a section in **README.md** for “Linux Installation”, explaining how to install the .deb on Debian/Ubuntu (and which versions are supported if relevant) or the .rpm on Fedora/RHEL, etc. Include instructions for both methods: using the system package (with a mention of needing root privileges, e.g. using `sudo dpkg -i nicels.deb` or using apt if we host a repository) and using the user-local installation (e.g. running a provided script or extracting a tarball to the home directory). Note any post-install steps (like “log out and log back in or source your profile if you added to PATH”) and emphasize that the YAML config files are installed to `/etc/dm17ryk/nicels/yaml` (for system installs) or `~/.nicels/yaml` (for user installs). Updating the README ensures users know how to get started with **nls** on Linux using the new packages."
  ],
  "scope": [
    "**Integrate CPack for DEB/RPM Packaging:** Extend the CMake build configuration to produce Debian and RPM packages as part of the build/release process. Add the appropriate CPack settings in **CMakeLists.txt** (under the Linux/Unix section) similarly to how the NSIS installer was set up for Windows. For example, set `CPACK_GENERATOR` to include `\"DEB\"` and `\"RPM\"` on Linux, and configure package metadata like name, version, and maintainer. Use the existing version variables (from the `VERSION` file and `project()` version) so that the package versions match the `nls --version` output. Set `CPACK_PACKAGE_CONTACT` or maintainer to an appropriate value (e.g., your name or project email) and `CPACK_PACKAGE_VENDOR` to identify the project. Include a brief summary and description for the packages (e.g., “Next-generation ls with icons and git support”). Ensure that CPack’s packaging install prefix is correctly set so files are not placed under an extra `/usr` path in the archive – explicitly use `set(CPACK_PACKAGING_INSTALL_PREFIX \"/\")` so that the install tree’s `/usr` directory is treated as the root of the package. Including CPack in this way will allow running `cpack -G DEB` or `cpack -G RPM` after building to produce the respective packages.",
    "**CMake Install Rules for Linux Directories:** Modify or add CMake install commands to place files in the proper locations for a Linux installation. Specifically, ensure the `nls` binary is installed to a bin directory in the package (e.g., `/usr/bin/`). The YAML configuration files should be installed to `/etc/dm17ryk/nicels/yaml/` on Unix systems. This may involve using CMake’s `install(FILES ...)` or `install(DIRECTORY ...)` for the YAML files. For instance, install all `*.yaml` files from the project’s `yaml/` source directory into `etc/dm17ryk/nicels/yaml` in the install tree. (Note: when using CPack, if the install prefix is `/usr`, installing to `etc/...` will actually end up at `/usr/etc/...` unless we adjust as above; by setting the packaging prefix to `/`, those files will correctly map to `/etc/...` in the final package.) Double-check that after installation, the directory structure in the package has `usr/bin/nls` and `etc/dm17ryk/nicels/yaml/*.yaml` as intended. If not already done, include <u>GNUInstallDirs</u> or define `CMAKE_INSTALL_SYSCONFDIR` to help manage the `/etc` path. The key is to ensure the compiled program and its config files are in standard filesystem locations so that they match the search paths coded in the application.",
    "**Declare Package Dependencies Automatically:** Implement dependency resolution for the packages by using available tools. For the .deb package, enable CPack’s integration with `dpkg-shlibdeps` by setting `CPACK_DEBIAN_PACKAGE_SHLIBDEPS ON`. This will invoke Debian’s dependency scanner on the packaged `nls` binary to detect needed library SONAMEs and translate them into package requirements (for example, it will add something like `libssl3 (>=1.1.1)` if OpenSSL is needed, etc.). Additionally, specify any known dependencies that might not be caught by shlibdeps (for instance, if `nls` invokes external tools or scripts, which it likely doesn’t aside from libc and libgit2’s needs). Similarly, for RPM, CPack by default can let rpm’s build process auto-find library dependencies; ensure this is working or explicitly set `CPACK_RPM_PACKAGE_REQUIRES` with any crucial dependencies. For example, if OpenSSL is used, the RPM might need `openssl` (or `openssl-libs`) listed. The goal is that after installing the package, running `nls` does not result in “library not found” errors because all required libs are present. Test this by installing the .deb/.rpm on a clean environment (or using a container) to see if it pulls in the needed libs. Adjust the dependency declarations as necessary if any are missing (e.g., if libstdc++ or others need to be explicitly mentioned, though on most systems those core libs are already installed).",
    "**Mark Configuration Files as Configurable:** Ensure that the packaging treats the YAML config files in `/etc/dm17ryk/nicels/yaml` as configuration files, so that user modifications to them are respected during upgrades. For Debian, this means listing those files as `conffiles` in the package control info. With CPack, we can achieve this by using the `CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA` variable to point to a custom `conffiles` file or by setting `CPACK_DEBIAN_<path>_FILE` properties on the install. We will include a `conffiles` file (in CPack’s staging area or through CMake) that enumerates each `/etc/dm17ryk/nicels/yaml/*.yaml` file. This way, if an admin has edited one of the global YAMLs, a future package upgrade will prompt them (or automatically preserve the old file with a `.dpkg-old` backup) instead of overwriting changes silently. For RPM, use `%config` directives for those files. CPack allows adding custom RPM spec segments via variables like `CPACK_RPM_SPEC_MORE_DEFINE` or similar. We should ensure the spec marks `/etc/dm17ryk/nicels/yaml/*` as config files. This step protects user or admin customizations of the global defaults and aligns with standard Linux packaging practices.",
    "**User-Only Installation Script:** Since package managers won’t run without root for system directories, create an alternative installation method for users without sudo. Implement a simple **install script** (e.g., `install_nls_user.sh` or a small Python script) that can be executed by a normal user to set up **nls** in their home directory. This script should take the built `nls` binary (either from a build artifact or by extracting from the .deb/.rpm) and copy it to `~/.local/bin/nls` (creating `~/.local/bin` if necessary, which many distros include in PATH by default). It should also copy the YAML config directory into the user’s home at `~/.nicels/yaml/`. If the user already has a `~/.nicels/yaml` directory (from a previous install or custom setup), the script should **back up** that directory first (e.g., rename it to `yaml.bak.timestamp`) before copying the new files, to avoid overwriting any changes the user made. The script can then place the new default YAMLs. It may also print a message reminding the user to ensure `~/.local/bin` is in their PATH (if not, instruct how to add it in their shell profile). By providing this script alongside the packages (or as part of the source), we give non-privileged users an easy way to upgrade to the latest version without needing root access. Add this script to the repository (e.g., under `tools/` or `scripts/`) and include its creation as part of this task.",
    "**Testing and QA for Packages:** After implementing the packaging, thoroughly test the installation scenarios. Build the .deb and .rpm using CPack (for example, on Ubuntu for .deb and on Fedora or using alien for .rpm if needed) and try installing them. Test a **system-wide install** on a clean system: install the .deb via `sudo dpkg -i` (or add it to a local apt repo) and ensure that `nls` is placed in `/usr/bin`, YAMLs in `/etc/dm17ryk/nicels/yaml`. Run `nls --help` and a sample `nls` command to confirm it finds its config (since we expect it to load the `/etc/...` YAML files by default). Next, test **upgrade**: install an older version .deb if available (or simulate by tweaking version number), then install the new one and verify that the old binary is replaced and that no duplicate files exist (and that if a YAML in /etc was edited, the package upgrade either kept it or created a `.dpkg-old` as appropriate). Similarly, test the **RPM** on a RPM-based distro with `rpm -Uvh` for install/upgrade. Also test the **user install script**: on a fresh user account, run the script to install to home. Verify that `~/.local/bin/nls` exists and works (you may need to log out/in or manually update PATH if not automatically picked up), and that the YAMLs are in `~/.nicels/yaml`. If `~/.nicels/yaml` already existed, check that it was backed up and the new files placed. Document any steps needed (e.g., “after running the script, open a new terminal or source your ~/.profile to use nls”). Only once all these scenarios succeed without issues should the task be considered complete.",
    "**Prepare Source Package Distribution:** Using CPack or manual steps, create a source archive of the project. Configure `CPACK_SOURCE_GENERATOR` (e.g., `TGZ` or `ZIP`) and set `CPACK_SOURCE_IGNORE_FILES` to exclude build artifacts. Running `cpack -G TGZ --config CPackSourceConfig.cmake` should produce a tarball of the source code (including the `yaml` directory and `third-party/libgit2` submodule, etc.). Ensure this archive includes everything needed to build: source files, CMake scripts, submodules, etc. Additionally, provide metadata about build requirements: for example, in README or a `INSTALL` file, list the packages required to compile nicels (such as a C++ compiler, CMake 3.16+ or above, Ninja, OpenSSL dev libraries, etc.). For a formal Debian source package, one would include a debian/control file with Build-Depends; for now, a clear documentation of dependencies suffices. The source package allows advanced users or distro maintainers to rebuild the project from source. Make sure to test that one can take the source tarball on a clean system, install the needed build dependencies, and successfully compile and package `nls`. By doing this, we comply with open-source distribution norms and ensure nicels can be built by others.",
    "**Documentation and README Updates:** Update **README.md** to include a Linux installation section. This should instruct users on how to use the new .deb and .rpm packages. For example, tell users where to obtain the packages (e.g., “Download the `.deb` from the Releases page and install with `sudo dpkg -i nicels_<version>_amd64.deb`”, or if we plan to publish to a PPA or repository, describe `apt install nicels`). Similarly, for RPM: “Install via `rpm -i nicels-<version>.rpm` or use `dnf install` if we provide a repository.” Include guidance on the need for root privileges for these system-wide installs. Then mention the user-local installation option: e.g., “If you don’t have admin rights, you can still use nicels by running the provided `install_nls_user.sh` script which will install nicels just for your account.” Explain what the script does at a high level and that after running it, the user should have `nls` in their PATH. Also note where the configuration files end up in each case (reiterate that global config is in `/etc/dm17ryk/nicels/yaml`, and that users can override settings in `~/.nicels/yaml`). If applicable, mention supported OS versions (for example, which Linux distributions we’ve tested on or any minimum requirements like glibc version or libstdc++). Finally, advise how to uninstall: for system packages, use the package manager (`apt remove nicels` or `rpm -e nicels`); for user install, simply remove the `nls` binary and the `~/.nicels/yaml` folder (or restore from backup if needed). These additions to the README will ensure Linux users have clear instructions, complementing the Windows installer section already present."
  ],
  "exclusions": [
    "**No Core Logic Changes:** Do not modify the core functionality or code of `nls` beyond what is necessary for packaging. The search paths for config files, etc., have already been implemented (the program knows to look in `/etc/dm17ryk/nicels/yaml` and `~/.nicels/yaml`). We should not alter that logic now, only ensure the files are installed in those locations. Similarly, do not change how `nls` outputs or any command-line behavior; this task is purely about packaging and installation, not about changing the tool’s runtime features.",
    "**Do Not Embed Config Inside Binary:** Continue to keep YAML configuration files as external resources. We will not compile the YAML data into the `nls` executable or otherwise embed them; they should remain regular files on disk. The packaging will deliver these files to the appropriate directory. This approach maintains transparency (users can open and edit the YAML configs if needed) and aligns with common practice on Linux (config files in /etc or in the user’s home, not hidden inside binaries).",
    "**No Interactive Prompts in .deb/.rpm:** Debian and RPM packages are non-interactive by design (aside from debconf scripts, which we won’t use here). We will not attempt to create an installer GUI or terminal prompt to ask the user “system or user install” during .deb/.rpm installation – that’s not supported. The distinction between system and user install will be achieved by providing the separate user-install script or archive, not by making the .deb itself interactive. Likewise, avoid any post-install scripts that require user input. The installation should be silent aside from standard package manager messages.",
    "**No Additional Package Formats:** Focus only on the requested .deb and .rpm formats (and a tarball for source/binary if needed). We will not create Snap, Flatpak, AppImage or other package types in this task. Those could be considered in the future but are out of scope now. By concentrating on .deb and .rpm, we target the most common Linux distribution families. (macOS packaging is separate and not covered here, and Windows is already done with NSIS.)",
    "**Preserve Build-from-Source Flow:** Ensure that whatever changes are made for packaging do not break the ability to build and run `nls` from source for development purposes. Developers should still be able to compile the project and run `./nls` from the build directory using the local `yaml/` files (the program already prioritizes local `yaml/` when present). The install rules and CPack settings should be configured such that they only apply when doing an install or package step; just building the binary in-place should not suddenly require writing to /etc or similar. In short, packaging is an additive capability and should not disrupt the normal development workflow or usage of the tool in an uninstalled manner.",
    "**Avoid Redundant File Placement:** Don’t install the same files to multiple locations. For instance, do not put YAML files in both `/etc/nicels/yaml` and somewhere under `/usr/share` – use the one canonical location for global config (`/etc/dm17ryk/nicels/yaml`). Similarly, do not place the binary in unconventional locations; stick to `/usr/bin` for system install. Consistency with FHS (Filesystem Hierarchy Standard) is important. The user install script likewise should place files in one set location under the home directory. We should not scatter files or duplicate them, as that could confuse users and complicate upgrades.",
    "**No Unnecessary Dependencies:** While declaring dependencies is important, do not add needless ones. Only include libraries or packages that `nls` truly needs. For example, `nls` probably doesn’t need any GUI libraries, DBus, etc., so the package should not pull those in. Keep the dependency list minimal (likely libc which is implicit, libstdc++ (implicit on systems with C++), and libssl/libcrypto if dynamically linked, plus maybe zlib or others if used by libgit2). Do not mark libgit2 as a runtime dependency since we are statically linking it (the binary includes it already). Over-specifying dependencies can limit portability or cause conflicts, so stick to what’s actually required for execution.",
    "**No Version Number Hardcoding in Docs/Script:** When writing instructions or the user install script, do not hardcode a specific version number of `nicels` in paths or messages that would require manual updating for each release. Use placeholders or variables where possible (the CPack config will insert version in package names). For README instructions, it’s fine to give an example, but also mention “<version>” as a placeholder or instruct to use the latest version. This avoids the documentation becoming outdated on the next release. Similarly, if the user script prints the version, have it derive from the binary (`nls --version`) rather than a constant string."
  ],
  "architectural_recommendations": [
    "**Leverage CPack for Cross-Platform Packaging:** Using CPack means we keep all packaging logic in CMake, benefiting from the existing build scripts. This reduces maintenance (no separate manual Debian packaging files to update each release). The CPack DEB/RPM generators will create the necessary control files and spec files under the hood. We should still review the generated package metadata (by inspecting the `.deb` control or `.rpm` spec after generation) to verify things like correct Section, Priority (which we can optionally set via `CPACK_DEBIAN_PACKAGE_SECTION` etc.), but overall CPack will handle the heavy lifting. By integrating packaging into our build system, releasing a new version becomes as simple as updating the version file, building, and running CPack, which aligns with our automated approach.",
    "**Use Standard Paths and Variables:** Introduce the use of `GNUInstallDirs` in CMake to manage standard install directories. This provides variables like `CMAKE_INSTALL_BINDIR` (`bin`), `CMAKE_INSTALL_SYSCONFDIR` (`etc`), etc., which we can concatenate with our specific path (e.g., `install(DIRECTORY yaml/ DESTINATION ${CMAKE_INSTALL_SYSCONFDIR}/dm17ryk/nicels/yaml)`). This approach automatically adapts if the install prefix is changed. For instance, if someone sets `CMAKE_INSTALL_PREFIX=/usr`, `CMAKE_INSTALL_SYSCONFDIR` might remain `etc` (to install to /usr/etc), but since we set the CPack packaging prefix to /, those files will end up in /etc. Using these abstractions makes the CMake install commands clearer and more portable. Also, rely on CMake’s component and component-group features if needed (though for now one component for all is fine).",
    "**Ensure Path Resolution Consistency:** After installation, `nls` will rely on the logic we implemented in `ResourceManager::initPaths` (or similar) to find config files. It’s important that our packaging choices align with that logic. We’ve added `/etc/dm17ryk/nicels/yaml` and `~/.nicels/yaml` to the search paths already. We should double-check that when the binary is installed to `/usr/bin`, there isn’t any unintended behavior (like previously it might have looked in the executable’s parent directory for a `yaml/` folder – which would now be `/usr/yaml` or `/yaml`, which doesn’t exist). Likely, the search order puts `/etc/...` and `~/.nicels/yaml` ahead of any exe-relative path if running from `/usr/bin`. If needed, we could adjust the search order to prefer /etc when running from an installed context. However, given the prior task, it’s probably already handled. Just keep this in mind: the packaging is predicated on the resource path logic working as intended for an installed binary.",
    "**Backup and Merge Strategy for Config:** The user install script’s approach to backing up config highlights a general principle: we never want to delete or overwrite user data unexpectedly. By backing up `~/.nicels/yaml` when doing a fresh user install, we avoid data loss. In the future, we might consider merging changes (like if new keys are added in a default YAML, merging with user’s copy), but that’s beyond this task. Right now, a safe rename of the old config directory is sufficient. We should also perhaps log or print what we did (“Old config found at ~/.nicels/yaml; moved to ~/.nicels/yaml.bak”) so the user is aware. In packaging (system-wide), the analogous situation (admin modified a file) is handled via conffile mechanism as discussed. Always favor preserving the user’s intent over blindly replacing files.",
    "**Testing in Clean Environments:** It’s recommended to test the generated packages in isolation. Consider using Docker containers or virtual machines for an Ubuntu/Debian and a Fedora/CentOS environment. Install our .deb in a container that has only the base OS, and see if it pulls in all needed dependencies or if any error occurs. Do the same for .rpm with `yum/dnf`. This isolates issues like “works on my dev machine because I already had libXYZ installed”. By testing on a minimal system, we catch missing dependencies. Also test removal of the package to ensure it cleans up (the binary and config files in /etc should be removed by package manager on uninstall, except perhaps config files if modified – dpkg will leave modified conffiles as orphans, which is standard). These practices ensure that when real users install the packages, they have a smooth experience.",
    "**Maintain Portability Across Distros:** The .deb we create should be as generic as possible for Debian-based systems (Ubuntu, etc.), and the .rpm generic for Fedora/RHEL. Avoid hardcoding distro-specific things like paths that only exist on one distro. `/etc/dm17ryk/nicels/yaml` is a neutral choice and should exist on all. The dependency names might need to be chosen carefully: for instance, if linking against OpenSSL 3, Debian calls the package `libssl3`, whereas Red Hat might just use `openssl` library package. Using the shlibdeps and rpm auto-provides helps here, since they will generate dependencies on the actual library SONAME (which the system’s package manager knows how to satisfy). This way, our package will work on multiple versions of the distro (as long as a compatible OpenSSL is available). Keep the control fields like Maintainer, Section, etc., generic and valid. If distributing on a PPA or COPR, those can be refined later, but for now ensure the packages pass basic linting (`lintian` for debs might be used to check for common issues).",
    "**Automation of Release Artifacts:** Once this packaging is set up, consider adding a CMake target or a script that builds all release artifacts in one go (Windows NSIS, Debian, RPM, source tarball). That’s beyond this immediate task, but worth noting as an architectural improvement. For now, focus on manual invocation (documented in README, e.g., “run `cpack -G DEB -G RPM` on Linux to produce packages”). This will help any contributor or CI system to generate installers easily. Ensuring the process is deterministic (same file list every time, consistent naming) is important for trust in the release process.",
    "**Security Considerations:** While packaging, ensure that file permissions are appropriate. The `nls` binary in the package should be executable (mode 755) and owned by root:root in system installs. The YAML files in /etc should be readable by all users (644) but maybe not writable (which is standard; only root can edit them). If we need the program to write to config (likely not, it’s just reading), we keep them read-only for regular users. The user install script, when copying files, should copy with safe permissions as well (the user’s own files can be user-writable). Also, be mindful that the install script running arbitrary copy commands should be reviewed for any potential to overwrite unintended files – our targeting of specific directories mitigates this. These are mostly standard practices, and CPack defaults usually handle permissions correctly, but worth double-checking the final package with `dpkg -c package.deb` or `rpm -qlp package.rpm` to see file modes and ownership.",
    "**Licensing and Metadata:** Set the package license field appropriately (for RPM, e.g., `CPACK_RPM_PACKAGE_LICENSE \"MIT\"` if the project is MIT-licensed). Include the LICENSE file in the package documentation if desired (CPack can install it to `/usr/share/doc/nicels/` or similar – though not strictly necessary, it’s a nice touch). Also set `CPACK_PACKAGE_DESCRIPTION_SUMMARY` to a short tagline (one line) and the longer description (CPACK_DEBIAN_PACKAGE_DESCRIPTION, possibly) if needed for Debian. These metadata fields make the package look professional when someone inspects it. Since this is a CLI tool, we probably don’t have a man page yet; not required for this task, but consider adding one in the future for completeness. For now, ensure at least the `--help` output is comprehensive, and maybe include a pointer in the README that more usage info is available via `nls --help` or the project page."
  ],
  "final_output_instructions": [
    "Provide the updated **CMakeLists.txt** content showing the new CPack configuration for Debian and RPM. This should include any `include(CPack)` changes, definitions of CPACK variables (package name, version, maintainer, description, license for RPM, setting CPACK_GENERATOR, CPACK_PACKAGING_INSTALL_PREFIX, CPACK_DEBIAN_PACKAGE_SHLIBDEPS, etc.). Show the install rules added or modified (e.g., the `install(DIRECTORY yaml/...` command for the config files). Present the relevant portions of CMakeLists.txt (or the whole file if necessary for context) with the new changes clearly marked.",
    "Include the full content of any **new files** created, such as the user installation script (e.g., `install_nls_user.sh`). Provide the script’s source code with comments explaining its steps. If a custom `conffiles` file was added for Debian, or any custom CPack template adjustments for RPM, include those as well in full. List these new files with their intended paths in the repository (for example, `tools/install_nls_user.sh` and perhaps something like `cmake/CPackDebConffiles.txt` if used).",
    "Show modifications to **README.md** where the Linux installation instructions are added. It may be easiest to provide the entire new Installation section (or the whole README if it’s not too large) so that context is clear. The README update should reflect what was described: instructions for .deb, .rpm, and the user script usage. Ensure formatting (headings, code blocks for commands, etc.) is correct in Markdown.",
    "Ensure that all provided content is complete and could be applied directly to the repository. The answer should effectively serve as a patch: any altered file should be presented with its new content, and new files provided in entirety. Verify that paths in install commands (like `/etc/dm17ryk/nicels/yaml`) match exactly the code and that the script uses correct directory names (`.nicels`). The changes should be consistent with each other (e.g., the README says to run `install_nls_user.sh`, and that file indeed exists in the provided content). By supplying all these pieces, Codex (or a developer) can implement the packaging as specified."
  ]
}
